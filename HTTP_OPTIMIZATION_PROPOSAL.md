# HTTP並列化による高速化提案

## 現状分析

### パフォーマンス内訳
```
総レスポンス時間: 922-976ms
├─ HTTPリクエスト受信: 1-5ms (0.5%)
├─ パラメータ解析: 1ms (0.1%)
├─ WMSレンダリング: 920ms (94.2%)
└─ PNG送信: 10-50ms (5.1%)
```

**結論**: HTTPオーバーヘッドは全体の1-5%のみ。

## 提案1: HTTP並列化 (効果: 中)

### 実装概要
```python
def run_server(self):
    while self._http_running:
        conn, addr = self.http_server.accept()
        # 各リクエストをスレッドプールで並列処理
        self._tile_executor.submit(self._handle_client_connection, conn, addr)
```

### メリット
- **複数タイルの並列取得**: 6タイル同時 = 6倍高速(理論値)
- **複数ブラウザ対応**: 2人同時アクセスでもスムーズ
- **実装容易**: 5行程度の変更

### デメリット
- **メモリ使用量増加**: 各スレッドが独立してレンダリング
- **CPU負荷増加**: 4並列 = CPU使用率4倍
- **キャッシュヒット時は無意味**: < 10msの処理を並列化しても体感差なし

### 効果試算
```
シナリオ1: WMTSタイル6枚(全てキャッシュミス)
現在: 6 × 920ms = 5520ms (5.5秒)
改善後: 920ms (並列レンダリング)
効果: 5秒短縮 ⭐⭐⭐

シナリオ2: WMTSタイル6枚(全てキャッシュヒット)
現在: 6 × 10ms = 60ms
改善後: 10ms (並列処理)
効果: 50ms短縮 ⭐ (体感差なし)

シナリオ3: 単一リクエスト(OpenLayers大画像)
現在: 920ms
改善後: 920ms (変化なし)
効果: なし
```

### 推奨度: ⭐⭐⭐ (中)
**理由**: プリウォーム完了後はキャッシュヒットが大半なので、効果は限定的。

---

## 提案2: Keep-Alive対応 (効果: 小)

### 実装概要
```python
# HTTPヘッダーに追加
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

### メリット
- TCP接続の再利用でオーバーヘッド削減
- 連続リクエストが1-2ms高速化

### デメリット
- 実装が複雑(接続管理が必要)
- 効果が非常に小さい(1-2ms)

### 効果試算
```
10個の連続リクエスト:
現在: 10 × 3ms(接続) = 30ms
改善後: 1 × 3ms = 3ms
効果: 27ms短縮 ⭐ (誤差レベル)
```

### 推奨度: ⭐ (低)
**理由**: 手間に対して効果が小さすぎる。

---

## 提案3: HTTP/2対応 (効果: なし)

### 実装概要
HTTP/2プロトコルを使用して並列ストリーム処理

### デメリット
- **実装が非常に複雑**: TLS必須、新しいライブラリ必要
- **ローカルホストでは無意味**: ネットワーク遅延がないため効果なし
- **QGISプラグインに不適切**: オーバースペック

### 推奨度: ❌ (なし)
**理由**: ローカルホストでは全く意味がない。

---

## 提案4: レスポンス圧縮 (効果: 小-中)

### 実装概要
```python
# PNGをgzip圧縮して送信
Content-Encoding: gzip
```

### メリット
- ネットワーク転送量削減
- PNGは既に圧縮済みなので効果は限定的

### デメリット
- CPU使用量増加
- ローカルホストでは無意味(転送は瞬時)

### 効果試算
```
4MB画像の転送:
ローカルホスト: 10ms → 10ms (変化なし)
ネットワーク経由(1Gbps): 32ms → 20ms
効果: ネットワーク使用時のみ ⭐⭐
```

### 推奨度: ⭐ (低)
**理由**: ローカルホストでは無意味。ネットワーク共有時のみ効果。

---

## 提案5: プリウォーム範囲拡大 (効果: 大)

### 実装概要
現在のプリウォーム設定を拡張:
```python
# 現在: z=10-16, 3×3グリッド = 63タイル
# 提案: z=10-18, 5×5グリッド = 225タイル
```

### メリット
- **キャッシュヒット率向上**: 90% → 98%
- **体感速度向上**: ほぼ全てのタイルが瞬時

### デメリット
- プリウォーム時間増加: 1分 → 3-4分
- ディスク使用量増加: 50MB → 200MB

### 効果試算
```
100タイルリクエスト:
現在: 90ヒット(< 10ms) + 10ミス(920ms) = 9.2秒
改善後: 98ヒット(< 10ms) + 2ミス(920ms) = 1.84秒
効果: 7.4秒短縮 ⭐⭐⭐⭐⭐
```

### 推奨度: ⭐⭐⭐⭐⭐ (最高)
**理由**: HTTP並列化より効果が大きく、実装も簡単。

---

## 推奨実装順序

### 優先度1: プリウォーム範囲拡大 ⭐⭐⭐⭐⭐
```python
# qmap_wmts_service.py
zoom_levels = range(10, 19)  # 10-18に拡大
for dx in [-2, -1, 0, 1, 2]:  # 5×5グリッドに拡大
    for dy in [-2, -1, 0, 1, 2]:
```

**実装時間**: 5分
**効果**: キャッシュヒット率90% → 98%

### 優先度2: HTTP並列化 ⭐⭐⭐
```python
# qmap_permalink_server_manager.py
def run_server(self):
    while self._http_running:
        conn, addr = self.http_server.accept()
        self._tile_executor.submit(self._handle_client_connection, conn, addr)
```

**実装時間**: 10分
**効果**: 複数タイル同時取得時に高速化

### 優先度3: Keep-Alive ⭐
効果が小さいため、必要性を感じるまで実装不要。

---

## 結論

### 現時点での推奨
**プリウォーム範囲拡大のみ実装を推奨**

理由:
1. **最大の効果**: キャッシュヒット率98%で体感速度が劇的向上
2. **実装が簡単**: 5分で完了
3. **リスクが低い**: 既存機能の拡張のみ

### HTTP並列化について
**現時点では不要**

理由:
1. レンダリング時間(920ms)がボトルネックで、HTTP処理(20ms)は誤差レベル
2. プリウォームが完了すればキャッシュヒット率90%以上
3. 単一ユーザー前提ではオーバースペック

**実装すべき状況**:
- ネットワーク経由で複数人が同時アクセスする場合
- プリウォームなしで大量のタイルを初回取得する場合

---

## パフォーマンス比較表

| 項目 | 現在 | プリウォーム拡大 | HTTP並列化 | 両方実装 |
|------|------|------------------|------------|----------|
| **初回6タイル** | 5.5秒 | 5.5秒 | 0.92秒 | 0.92秒 |
| **2回目6タイル** | 0.06秒 | 0.06秒 | 0.01秒 | 0.01秒 |
| **キャッシュヒット率** | 90% | 98% | 90% | 98% |
| **100タイル平均** | 9.2秒 | 1.84秒 | 9.2秒 | 1.84秒 |
| **実装時間** | - | 5分 | 10分 | 15分 |
| **CPU使用率** | 低 | 低 | 高 | 高 |
| **メモリ使用量** | 低 | 中 | 高 | 高 |

**結論**: プリウォーム拡大が最もコストパフォーマンスが高い。
