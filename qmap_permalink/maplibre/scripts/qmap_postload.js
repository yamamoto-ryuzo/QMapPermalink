// Post-load helpers for the MapLibre HTML generated by qmap_maplibre.py
// This script expects the map instance to be passed to window.qmap_init_after_load
// or will be called by the HTML generator as window.qmap_init_after_load(map).

(function() {
  // Define a single post-load initializer that will be invoked with the map instance
  window.qmap_init_after_load = function(map) {
    try {
      // Add helper: addWfsLayer (mirrors previous inline implementation)
      // 付帯ヘルパー: スタイルから幾何タイプを推定
      function inferGeomFromStyleBySource(srcId) {
        try {
          var types = new Set();
          var allLayers = map.getStyle().layers || [];
          for (var i = 0; i < allLayers.length; i++) {
            var lyr = allLayers[i];
            if (lyr && lyr.source === srcId && lyr.type) {
              types.add(String(lyr.type));
            }
          }
          if (types.has('fill')) return 'Polygon';
          if (types.has('line')) return 'LineString';
          if (types.has('circle')) return 'Point';
        } catch (e) { /* ignore */ }
        return null;
      }

      function addWfsLayer(wfsUrl, sourceId, layerId, labelId, layerTitle, labelTitle) {
        // スタイルJSONから既にレイヤーが読み込まれている場合は、sourceだけ更新
        var sourceAlreadyExists = false;
        var layersFromStyleExist = false;
        
        try {
          sourceAlreadyExists = !!map.getSource(sourceId);
          var allLayers = map.getStyle().layers || [];
          for (var i = 0; i < allLayers.length; i++) {
            if (allLayers[i].source === sourceId) {
              layersFromStyleExist = true;
              console.log('Layer from style JSON already exists:', allLayers[i].id);
              break;
            }
          }
        } catch (e) {
          console.warn('Failed to check existing source/layers', e);
        }
        
        // スタイルJSONからレイヤーが既に追加されている場合は、
        // データソースの更新のみを行い、レイヤーは追加しない
        if (layersFromStyleExist && sourceAlreadyExists) {
          console.log('Source and layers already exist for:', sourceId, '- skipping WFS fetch (using style JSON data source)');
          // Register layers in wmtsLayers for control
          if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
            try {
              var styleLayers = map.getStyle().layers || [];
              for (var i = 0; i < styleLayers.length; i++) {
                if (styleLayers[i].source === sourceId) {
                  var fid = styleLayers[i].id;
                  // Skip if already registered
                  if (wmtsLayers.some(function(l) { return l && l.id === fid; })) continue;
                  // Determine title based on layer type
                  var fTitle = layerTitle;
                  if (fid.indexOf('label') >= 0 || fid.indexOf('symbol') >= 0) {
                    fTitle = labelTitle;
                  }
                  wmtsLayers.push({ id: fid, title: fTitle });
                }
              }
            } catch (e) {
              console.warn('Failed to register style layers', e);
            }
          }
          // ラベルレイヤーはスタイルに含まれないため、ここで追加して登録する
          try {
            if (!map.getLayer(labelId)) {
              var inferred = inferGeomFromStyleBySource(sourceId);
              var labelLayout = { 'text-field': ['get', 'label'], 'text-size': 14, 'text-allow-overlap': true };
              if (inferred === 'LineString') {
                labelLayout['symbol-placement'] = 'line';
                labelLayout['text-offset'] = [0, 1.0];
              } else if (inferred === 'Polygon') {
                labelLayout['symbol-placement'] = 'point';
              } else {
                labelLayout['text-offset'] = [0, 1.0];
                labelLayout['text-anchor'] = 'top';
              }
              map.addLayer({
                id: labelId,
                type: 'symbol',
                source: sourceId,
                filter: ['has', 'label'],
                layout: labelLayout,
                paint: {
                  'text-color': '#000000',
                  'text-halo-color': '#ffffff',
                  'text-halo-width': 2
                }
              });
              if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                if (!wmtsLayers.some(function(l){ return l && l.id === labelId; })) {
                  wmtsLayers.push({ id: labelId, title: labelTitle });
                }
              }
            }
          } catch (e) {
            console.warn('Failed to add/register label layer on existing-style branch', e);
          }
          return; // Skip WFS fetch - data is already being loaded from style JSON source
        }

        // まだスタイルJSONにこのsourceのレイヤーが含まれていない場合、個別に /maplibre-style?typename=sourceId を叩いて
        // 追加スタイルをマージする（成功したらフォールバックのWFSフェッチをスキップできる）
        async function tryInjectStyleForSource(id) {
          var encodedId = encodeURIComponent(id);
          var styleEndpoint = '/maplibre-style?typename=' + encodedId;
          try {
            console.log('Attempting style fetch for extra typename:', id);
            const resp = await fetch(styleEndpoint, { method: 'GET' });
            if (!resp.ok) throw new Error('style fetch failed: ' + resp.status);
            const styleJson = await resp.json();
            if (!styleJson || !styleJson.layers || !styleJson.sources) {
              console.warn('Style JSON missing layers/sources for:', id); return false;
            }
            if (map.getSource(id)) {
              console.log('Source already exists before style injection, skipping source add:', id);
            } else if (styleJson.sources[id]) {
              // 追加するソース（geojson）。style側は data に /wfs URL を持つため自動ロードされる。
              map.addSource(id, styleJson.sources[id]);
              console.log('Added source from style for:', id);
            } else {
              console.warn('Style JSON has no source entry for id:', id); return false;
            }
            // そのsourceを参照するレイヤーのみ抽出して追加（既存重複はスキップ）
            var addedAny = false;
            for (var li = 0; li < styleJson.layers.length; li++) {
              var lyr = styleJson.layers[li];
              if (!lyr || lyr.source !== id) continue;
              if (map.getLayer(lyr.id)) { continue; }
              map.addLayer(lyr); // 既存スタイル末尾に追加
              addedAny = true;
              console.log('Injected style layer:', lyr.id);
              // レイヤー制御へ登録
              if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                var fTitle = layerTitle;
                if (lyr.id.indexOf('label') >= 0 || lyr.id.indexOf('symbol') >= 0) { fTitle = labelTitle; }
                if (!wmtsLayers.some(function(l) { return l && l.id === lyr.id; })) {
                  wmtsLayers.push({ id: lyr.id, title: fTitle });
                }
              }
            }
            if (!addedAny) {
              console.warn('No layers injected from style for source:', id);
              return false;
            }
            return true;
          } catch (e) {
            console.warn('Failed injecting style for source:', id, e);
            return false;
          }
        }

        // スタイル未存在時はまずスタイルを試みる（成功すればWFSフォールバック不要）
        if (!layersFromStyleExist) {
          // 非同期だが、後続処理を簡潔にするため IIFE と then で制御
          return (async () => {
            var injected = await tryInjectStyleForSource(sourceId);
            if (injected) {
              console.log('Style injection succeeded for', sourceId, '- skipping WFS fetch.');
              // ラベルレイヤーは通常スタイルに含まれないため追加
              if (!map.getLayer(labelId)) {
                try {
                  var inferred = inferGeomFromStyleBySource(sourceId);
                  var labelLayout = { 'text-field': ['get', 'label'], 'text-size': 14, 'text-allow-overlap': true };
                  if (inferred === 'LineString') {
                    labelLayout['symbol-placement'] = 'line';
                    labelLayout['text-offset'] = [0, 1.0];
                  } else if (inferred === 'Polygon') {
                    labelLayout['symbol-placement'] = 'point';
                  } else {
                    labelLayout['text-offset'] = [0, 1.0];
                    labelLayout['text-anchor'] = 'top';
                  }
                  map.addLayer({
                    id: labelId,
                    type: 'symbol',
                    source: sourceId,
                    filter: ['has', 'label'],
                    layout: labelLayout,
                    paint: {
                      'text-color': '#000000',
                      'text-halo-color': '#ffffff',
                      'text-halo-width': 2
                    }
                  });
                  if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                    if (!wmtsLayers.some(function(l){ return l && l.id === labelId; })) {
                      wmtsLayers.push({ id: labelId, title: labelTitle });
                    }
                  }
                } catch (e) { console.warn('Failed to add label layer after style injection', e); }
              }
              return; // 完了
            }
            // 失敗した場合は従来のWFSフェッチによるフォールバックへ進む
            proceedWfsFetch();
          })();
        }

        // 既存ロジックでの WFS フェッチを関数化（スタイル注入失敗時のみ使用）
        function proceedWfsFetch() {
        
        const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
        const signal = controller ? controller.signal : null;
        let timeoutId = null;
        if (controller) timeoutId = setTimeout(() => controller.abort(), 5000);

        fetch(wfsUrl, { signal })
          .then(function(resp) {
            if (controller && timeoutId) clearTimeout(timeoutId);
            if (!resp.ok) throw new Error('WFS fetch failed: ' + resp.status);
            return resp.json();
          })
          .then(function(data) {
            try {
              if (data && data.features && data.features.length > 0) {
                const _props0 = data.features[0].properties || null;
                console.log('WFS: first feature properties ->', _props0);
                if (_props0 && typeof _props0._qgis_style !== 'undefined') {
                  console.log('WFS: _qgis_style ->', _props0._qgis_style);
                }
              } else {
                console.log('WFS: no features returned');
              }

              if (!map.getSource(sourceId)) {
                map.addSource(sourceId, { type: 'geojson', data: data });
              } else {
                try {
                  var s = map.getSource(sourceId);
                  if (s && typeof s.setData === 'function') { s.setData(data); }
                } catch (e) { console.warn('Failed to update existing source data', e); }
              }

              var geomType = null;
              if (data && data.features && data.features.length > 0) {
                for (var fi = 0; fi < data.features.length; fi++) {
                  var g = data.features[fi] && data.features[fi].geometry;
                  if (!g || !g.type) continue;
                  var coords = g.coordinates;
                  if (coords && Array.isArray(coords) && coords.length === 0) continue;
                  geomType = String(g.type);
                  break;
                }
              }

              if (geomType) {
                geomType = geomType.charAt(0).toUpperCase() + geomType.slice(1);
                if (geomType.indexOf('Multi') === 0) { geomType = geomType.replace(/Multi/i, ''); }
              }

              // スタイルは /maplibre-style エンドポイントから既に適用されているため、
              // レイヤーが既に存在する場合は何もしない（スタイルを上書きしない）
              // レイヤーが存在しない場合のみ、フォールバックスタイルで追加
              var layerExists = false;
              try {
                // Check if any layers using this source already exist
                // (they would have been added by the style JSON)
                var allLayers = map.getStyle().layers || [];
                for (var i = 0; i < allLayers.length; i++) {
                  if (allLayers[i].source === sourceId) {
                    layerExists = true;
                    console.log('Layer already exists in style for source:', sourceId);
                    break;
                  }
                }
              } catch (e) {
                console.warn('Failed to check existing layers', e);
              }

              // Only add layers if they don't already exist in the style
              if (!layerExists) {
                console.warn('No style found for source ' + sourceId + ', using fallback style');
                if (!geomType || geomType === 'Point' || geomType === 'MultiPoint') {
                  if (!map.getLayer(layerId)) {
                    map.addLayer({
                      id: layerId,
                      type: 'circle',
                      source: sourceId,
                      paint: {
                        'circle-radius': 6,
                        'circle-color': '#d62728',
                        'circle-stroke-color': '#fff',
                        'circle-stroke-width': 1
                      }
                    });
                  }
                } else if (geomType === 'LineString') {
                  if (!map.getLayer(layerId)) {
                    map.addLayer({
                      id: layerId,
                      type: 'line',
                      source: sourceId,
                      paint: { 'line-color': '#d62728', 'line-width': 3, 'line-opacity': 1.0 }
                    });
                  }
                } else if (geomType === 'Polygon') {
                  if (!map.getLayer(layerId)) {
                    map.addLayer({
                      id: layerId,
                      type: 'fill',
                      source: sourceId,
                      paint: { 'fill-color': '#d62728', 'fill-opacity': 0.4, 'fill-outline-color': '#fff' }
                    });
                  }
                } else {
                  if (!map.getLayer(layerId)) {
                    map.addLayer({
                      id: layerId,
                      type: 'circle',
                      source: sourceId,
                      paint: { 'circle-radius': 6, 'circle-color': '#d62728', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 }
                    });
                  }
                }
              }

              // ラベルレイヤーは常に追加（スタイルJSONには通常含まれない）
              if (!map.getLayer(labelId)) {
                var labelLayout = {
                  'text-field': ['get', 'label'],
                  'text-size': 14,
                  'text-allow-overlap': true
                };
                var labelPaint = {
                  'text-color': '#000000',
                  'text-halo-color': '#ffffff',
                  'text-halo-width': 2
                };

                if (geomType === 'LineString') {
                  labelLayout['symbol-placement'] = 'line';
                  labelLayout['text-offset'] = [0, 1.0];
                } else if (geomType === 'Polygon') {
                  labelLayout['symbol-placement'] = 'point';
                } else {
                  labelLayout['text-offset'] = [0, 1.0];
                  labelLayout['text-anchor'] = 'top';
                }

                map.addLayer({
                  id: labelId,
                  type: 'symbol',
                  source: sourceId,
                  filter: ['has', 'label'],
                  layout: labelLayout,
                  paint: labelPaint
                });
              }

              // Expose added layers to the WMTS/vector layer control
              // スタイルから読み込まれたレイヤーも含めて、すべてのWFSレイヤーを登録
              if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                // Check if this layer is already in wmtsLayers (from style JSON)
                var layerExists = wmtsLayers.some(function(l) { return l && (l.id === layerId || l.id === labelId); });
                if (!layerExists) {
                  // Only add if not already present
                  // Get actual layer IDs from the style (may differ from our expected IDs)
                  try {
                    var styleLayers = map.getStyle().layers || [];
                    var foundIds = [];
                    for (var i = 0; i < styleLayers.length; i++) {
                      if (styleLayers[i].source === sourceId) {
                        foundIds.push(styleLayers[i].id);
                      }
                    }
                    // Register all layers from this source
                    for (var j = 0; j < foundIds.length; j++) {
                      var fid = foundIds[j];
                      // Skip if already registered
                      if (wmtsLayers.some(function(l) { return l && l.id === fid; })) continue;
                      // Determine title based on layer type
                      var fTitle = layerTitle;
                      if (fid.indexOf('label') >= 0 || fid.indexOf('symbol') >= 0) {
                        fTitle = labelTitle;
                      }
                      wmtsLayers.push({ id: fid, title: fTitle });
                    }
                  } catch (e) {
                    console.warn('Failed to register style layers in control', e);
                    // Fallback: register expected IDs
                    wmtsLayers.push({ id: layerId, title: layerTitle });
                    wmtsLayers.push({ id: labelId, title: labelTitle });
                  }
                }
              }

            } catch (e) { console.warn('Failed to add WFS layer after successful fetch:', e); }
          })
          .catch(function(err) { console.warn('WFS fetch error (skipping WFS layer):', err); });
        }
        // スタイル注入が既に return していない（= layersFromStyleExist だった）場合のみ WFS を実行
        if (layersFromStyleExist) {
          proceedWfsFetch();
        }
      }

      // Expose addWfsLayer globally for other scripts if needed
      window.qmap_addWfsLayer = addWfsLayer;

      // Populate GetCapabilities UI and call addWfsLayer for each available type
      try {
        fetch('/wfs?SERVICE=WFS&REQUEST=GetCapabilities')
          .then(resp => resp.text())
          .then(xmlText => {
            const parser = new window.DOMParser();
            const xml = parser.parseFromString(xmlText, 'text/xml');
            const featureTypes = xml.getElementsByTagName('FeatureType');
            const control = document.getElementById('layerControl');
            
            // WFSレイヤー用のチェックボックスを作成する前に、既存のものをチェック
            var processedSources = new Set();
            
            for (let i = 0; i < featureTypes.length; i++) {
              const ft = featureTypes[i];
              const nameElem = ft.getElementsByTagName('Name')[0];
              const titleElem = ft.getElementsByTagName('Title')[0];
              if (!nameElem) continue;
              const id = nameElem.textContent;
              const safeId = encodeURIComponent(id);
              const expectedLayerId = id + '_layer';
              const expectedLabelId = id + '_label';
              const labelText = (titleElem ? titleElem.textContent : id);

              // 既にwmtsLayersに登録されているかチェック（重複防止）
              var alreadyInWmts = false;
              if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                alreadyInWmts = wmtsLayers.some(function(l) {
                  return l && (l.id === id || l.id === expectedLayerId || l.title === labelText || l.title === `WFS: ${id}`);
                });
              }
              
              // UIに既に追加されているかチェック
              var existingCb = document.getElementById('cb_' + safeId);
              
              if (!existingCb && !alreadyInWmts) {
                const row = document.createElement('div');
                row.style.marginBottom = '4px';
                const cb = document.createElement('input'); 
                cb.type = 'checkbox'; 
                cb.id = 'cb_' + safeId; 
                cb.checked = true; 
                cb.style.marginRight = '6px';
                const label = document.createElement('label'); 
                label.htmlFor = cb.id; 
                label.innerHTML = labelText;
                row.appendChild(cb); 
                row.appendChild(label); 
                control.appendChild(row);

                cb.addEventListener('change', function() {
                  try {
                    const visibility = cb.checked ? 'visible' : 'none';
                    // スタイルJSONから読み込まれたレイヤーを含む、このソースを使用するすべてのレイヤーを制御
                    var controlledCount = 0;
                    try {
                      var allLayers = map.getStyle().layers || [];
                      for (var li = 0; li < allLayers.length; li++) {
                        var layer = allLayers[li];
                        if (layer.source === id) {
                          // このソースを使用するすべてのレイヤーの表示を切り替え
                          try {
                            map.setLayoutProperty(layer.id, 'visibility', visibility);
                            controlledCount++;
                            console.log('Set visibility for layer:', layer.id, 'to', visibility);
                          } catch (e) {
                            console.warn('Failed to set visibility for layer:', layer.id, e);
                          }
                        }
                      }
                    } catch (e) {
                      console.warn('Failed to enumerate layers for source:', id, e);
                    }
                    
                    // フォールバック: 期待されるレイヤーIDも試す
                    if (controlledCount === 0) {
                      if (map.getLayer(expectedLayerId)) { 
                        map.setLayoutProperty(expectedLayerId, 'visibility', visibility); 
                        controlledCount++;
                      }
                      if (map.getLayer(expectedLabelId)) { 
                        map.setLayoutProperty(expectedLabelId, 'visibility', visibility); 
                        controlledCount++;
                      }
                    }
                    
                    if (controlledCount === 0) {
                      console.warn('No layers found for source:', id);
                    }
                  } catch (e) { console.warn('Failed to toggle layer visibility', e); }
                });
                
                processedSources.add(id);
              }

              const already = (typeof wmtsLayers !== 'undefined') ? wmtsLayers.find(function(e) { return e && e.title === `WFS: ${id}`; }) : null;
              if (!already) {
                addWfsLayer(`/wfs?SERVICE=WFS&REQUEST=GetFeature&TYPENAMES=${encodeURIComponent(id)}&OUTPUTFORMAT=application/json&MAXFEATURES=1000`, id, expectedLayerId, expectedLabelId, `WFS: ${id}`, `WFS: ${id} (labels)`);
              }
            }
          })
          .catch(err => { console.warn('Failed to fetch WFS GetCapabilities:', err); });
      } catch (e) { console.warn('WFS GetCapabilities setup failed', e); }

      // Build the static layer control UI from wmtsLayers (may have been appended by addWfsLayer above)
      try {
        const control = document.getElementById('layerControl');
        if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
          wmtsLayers.forEach(function(layerInfo) {
            // 既にUIに追加されているかチェック（重複防止）
            var cbId = 'cb_' + encodeURIComponent(layerInfo.id);
            if (document.getElementById(cbId)) {
              console.log('Layer control already exists for:', layerInfo.id);
              return; // skip duplicates
            }
            
            const row = document.createElement('div'); 
            row.style.marginBottom = '4px';
            const cb = document.createElement('input'); 
            cb.type = 'checkbox'; 
            cb.id = cbId; 
            cb.checked = true; 
            cb.style.marginRight = '6px';
            const label = document.createElement('label'); 
            label.htmlFor = cb.id; 
            label.textContent = layerInfo.title || layerInfo.id;
            row.appendChild(cb); 
            row.appendChild(label); 
            control.appendChild(row);

            cb.addEventListener('change', function() {
              try {
                const visibility = cb.checked ? 'visible' : 'none';
                var controlled = false;
                
                // Try to control the specific layer by ID first
                if (map.getLayer(layerInfo.id)) { 
                  map.setLayoutProperty(layerInfo.id, 'visibility', visibility); 
                  controlled = true;
                  console.log('Set visibility for layer:', layerInfo.id, 'to', visibility);
                }
                
                // If layer not found, try to find it by source (for style JSON layers)
                if (!controlled) {
                  try {
                    var allLayers = map.getStyle().layers || [];
                    for (var i = 0; i < allLayers.length; i++) {
                      var layer = allLayers[i];
                      // Match by layer ID or source ID
                      if (layer.id === layerInfo.id || layer.source === layerInfo.id) {
                        map.setLayoutProperty(layer.id, 'visibility', visibility);
                        controlled = true;
                        console.log('Set visibility for layer via source:', layer.id, 'to', visibility);
                      }
                    }
                  } catch (e) {
                    console.warn('Failed to search layers by source', e);
                  }
                }
                
                if (!controlled) {
                  console.warn('Layer not found on map yet:', layerInfo.id);
                }
              } catch (e) { console.warn('Failed to toggle layer visibility', e); }
            });
          });
        }
      } catch (e) { console.warn('layer control setup failed', e); }

      // Pitch toggle setup
      try {
        const pitchBtn = document.getElementById('pitchToggle');
        let pitchLocked = true;
        const _enforcePitch = function() { try { if (map.getPitch && Math.abs(map.getPitch()) > 0.0001) { map.setPitch(0); } } catch (e) { } };
        function lockPitch() { try { map.setPitch(0); } catch (e) {} try { if (map.on) map.on('move', _enforcePitch); } catch(e) {} pitchLocked = true; pitchBtn.textContent = '斜め許可'; }
        function unlockPitch() { try { if (map.off) map.off('move', _enforcePitch); } catch(e) {} pitchLocked = false; pitchBtn.textContent = '斜め禁止'; }
        pitchBtn.addEventListener('click', function() { if (!pitchLocked) lockPitch(); else unlockPitch(); });
        try { lockPitch(); } catch(e) {}
      } catch (e) { console.warn('pitch toggle setup failed', e); }

    } catch (e) { console.warn('qmap_postload failed', e); }
  };
})();
