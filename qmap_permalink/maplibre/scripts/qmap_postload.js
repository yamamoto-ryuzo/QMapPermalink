// Post-load helpers for the MapLibre HTML generated by qmap_maplibre.py
// This script expects the map instance to be passed to window.qmap_init_after_load
// or will be called by the HTML generator as window.qmap_init_after_load(map).

(function() {
  // Define a single post-load initializer that will be invoked with the map instance
  window.qmap_init_after_load = function(map) {
    try {
      // Add helper: addWfsLayer (mirrors previous inline implementation)
      function addWfsLayer(wfsUrl, sourceId, layerId, labelId, layerTitle, labelTitle) {
        const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
        const signal = controller ? controller.signal : null;
        let timeoutId = null;
        if (controller) timeoutId = setTimeout(() => controller.abort(), 5000);

        fetch(wfsUrl, { signal })
          .then(function(resp) {
            if (controller && timeoutId) clearTimeout(timeoutId);
            if (!resp.ok) throw new Error('WFS fetch failed: ' + resp.status);
            return resp.json();
          })
          .then(function(data) {
            try {
              if (data && data.features && data.features.length > 0) {
                const _props0 = data.features[0].properties || null;
                console.log('WFS: first feature properties ->', _props0);
                if (_props0 && typeof _props0._qgis_style !== 'undefined') {
                  console.log('WFS: _qgis_style ->', _props0._qgis_style);
                }
              } else {
                console.log('WFS: no features returned');
              }

              if (!map.getSource(sourceId)) {
                map.addSource(sourceId, { type: 'geojson', data: data });
              } else {
                try {
                  var s = map.getSource(sourceId);
                  if (s && typeof s.setData === 'function') { s.setData(data); }
                } catch (e) { console.warn('Failed to update existing source data', e); }
              }

              var geomType = null;
              if (data && data.features && data.features.length > 0) {
                for (var fi = 0; fi < data.features.length; fi++) {
                  var g = data.features[fi] && data.features[fi].geometry;
                  if (!g || !g.type) continue;
                  var coords = g.coordinates;
                  if (coords && Array.isArray(coords) && coords.length === 0) continue;
                  geomType = String(g.type);
                  break;
                }
              }

              if (geomType) {
                geomType = geomType.charAt(0).toUpperCase() + geomType.slice(1);
                if (geomType.indexOf('Multi') === 0) { geomType = geomType.replace(/Multi/i, ''); }
              }

              if (!geomType || geomType === 'Point' || geomType === 'MultiPoint') {
                if (!map.getLayer(layerId)) {
                  map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                      'circle-radius': 6,
                      'circle-color': '#d62728',
                      'circle-stroke-color': '#fff',
                      'circle-stroke-width': 1
                    }
                  });
                }
                if (!map.getLayer(labelId)) {
                  map.addLayer({
                    id: labelId,
                    type: 'symbol',
                    source: sourceId,
                    filter: ['has', 'label'],
                    layout: {
                      'text-field': ['get', 'label'],
                      'text-size': 14,
                      'text-offset': [0, 1.0],
                      'text-anchor': 'top',
                      'text-allow-overlap': true
                    },
                    paint: {
                      'text-color': '#000000',
                      'text-halo-color': '#ffffff',
                      'text-halo-width': 2
                    }
                  });
                }
              } else if (geomType === 'LineString') {
                if (!map.getLayer(layerId)) {
                  map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: { 'line-color': '#d62728', 'line-width': 3, 'line-opacity': 1.0 }
                  });
                }
                if (!map.getLayer(labelId)) {
                  map.addLayer({
                    id: labelId,
                    type: 'symbol',
                    source: sourceId,
                    filter: ['has', 'label'],
                    layout: {
                      'symbol-placement': 'line',
                      'text-field': ['get', 'label'],
                      'text-size': 14,
                      'text-offset': [0, 1.0],
                      'text-allow-overlap': true
                    },
                    paint: { 'text-color': '#000000', 'text-halo-color': '#ffffff', 'text-halo-width': 2 }
                  });
                }
              } else if (geomType === 'Polygon') {
                if (!map.getLayer(layerId)) {
                  map.addLayer({
                    id: layerId,
                    type: 'fill',
                    source: sourceId,
                    paint: { 'fill-color': '#d62728', 'fill-opacity': 0.4, 'fill-outline-color': '#fff' }
                  });
                }
                if (!map.getLayer(labelId)) {
                  map.addLayer({
                    id: labelId,
                    type: 'symbol',
                    source: sourceId,
                    filter: ['has', 'label'],
                    layout: { 'symbol-placement': 'point', 'text-field': ['get', 'label'], 'text-size': 14, 'text-allow-overlap': true },
                    paint: { 'text-color': '#000000', 'text-halo-color': '#ffffff', 'text-halo-width': 2 }
                  });
                }
              } else {
                if (!map.getLayer(layerId)) {
                  map.addLayer({
                    id: layerId,
                    type: 'circle',
                    source: sourceId,
                    paint: { 'circle-radius': 6, 'circle-color': '#d62728', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 }
                  });
                }
              }

              // Expose added layers to the WMTS/vector layer control
              if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
                wmtsLayers.push({ id: layerId, title: layerTitle });
                wmtsLayers.push({ id: labelId, title: labelTitle });
              }

            } catch (e) { console.warn('Failed to add WFS layer after successful fetch:', e); }
          })
          .catch(function(err) { console.warn('WFS fetch error (skipping WFS layer):', err); });
      }

      // Expose addWfsLayer globally for other scripts if needed
      window.qmap_addWfsLayer = addWfsLayer;

      // Populate GetCapabilities UI and call addWfsLayer for each available type
      try {
        fetch('/wfs?SERVICE=WFS&REQUEST=GetCapabilities')
          .then(resp => resp.text())
          .then(xmlText => {
            const parser = new window.DOMParser();
            const xml = parser.parseFromString(xmlText, 'text/xml');
            const featureTypes = xml.getElementsByTagName('FeatureType');
            const control = document.getElementById('layerControl');
            for (let i = 0; i < featureTypes.length; i++) {
              const ft = featureTypes[i];
              const nameElem = ft.getElementsByTagName('Name')[0];
              const titleElem = ft.getElementsByTagName('Title')[0];
              if (!nameElem) continue;
              const id = nameElem.textContent;
              const safeId = encodeURIComponent(id);
              const expectedLayerId = id + '_layer';
              const expectedLabelId = id + '_label';
              const labelText = (titleElem ? titleElem.textContent : id);

              const row = document.createElement('div');
              row.style.marginBottom = '4px';
              const cb = document.createElement('input'); cb.type = 'checkbox'; cb.id = 'cb_' + safeId; cb.checked = true; cb.style.marginRight = '6px';
              const label = document.createElement('label'); label.htmlFor = cb.id; label.innerHTML = labelText;
              row.appendChild(cb); row.appendChild(label); control.appendChild(row);

              cb.addEventListener('change', function() {
                try {
                  const visibility = cb.checked ? 'visible' : 'none';
                  if (map.getLayer(expectedLayerId)) { map.setLayoutProperty(expectedLayerId, 'visibility', visibility); }
                  if (map.getLayer(expectedLabelId)) { map.setLayoutProperty(expectedLabelId, 'visibility', visibility); }
                } catch (e) { console.warn('Failed to toggle layer visibility', e); }
              });

              const already = (typeof wmtsLayers !== 'undefined') ? wmtsLayers.find(function(e) { return e && e.title === `WFS: ${id}`; }) : null;
              if (!already) {
                addWfsLayer(`/wfs?SERVICE=WFS&REQUEST=GetFeature&TYPENAMES=${encodeURIComponent(id)}&OUTPUTFORMAT=application/json&MAXFEATURES=1000`, id, expectedLayerId, expectedLabelId, `WFS: ${id}`, `WFS: ${id} (labels)`);
              }
            }
          })
          .catch(err => { console.warn('Failed to fetch WFS GetCapabilities:', err); });
      } catch (e) { console.warn('WFS GetCapabilities setup failed', e); }

      // Build the static layer control UI from wmtsLayers (may have been appended by addWfsLayer above)
      try {
        const control = document.getElementById('layerControl');
        if (typeof wmtsLayers !== 'undefined' && Array.isArray(wmtsLayers)) {
          wmtsLayers.forEach(function(layerInfo) {
            const row = document.createElement('div'); row.style.marginBottom = '4px';
            const cb = document.createElement('input'); cb.type = 'checkbox'; cb.id = 'cb_' + encodeURIComponent(layerInfo.id); cb.checked = true; cb.style.marginRight = '6px';
            const label = document.createElement('label'); label.htmlFor = cb.id; label.textContent = layerInfo.title || layerInfo.id;
            row.appendChild(cb); row.appendChild(label); control.appendChild(row);

            cb.addEventListener('change', function() {
              try {
                const visibility = cb.checked ? 'visible' : 'none';
                if (map.getLayer(layerInfo.id)) { map.setLayoutProperty(layerInfo.id, 'visibility', visibility); }
                else { console.warn('Layer not found on map yet:', layerInfo.id); }
              } catch (e) { console.warn('Failed to toggle layer visibility', e); }
            });
          });
        }
      } catch (e) { console.warn('layer control setup failed', e); }

      // Pitch toggle setup
      try {
        const pitchBtn = document.getElementById('pitchToggle');
        let pitchLocked = true;
        const _enforcePitch = function() { try { if (map.getPitch && Math.abs(map.getPitch()) > 0.0001) { map.setPitch(0); } } catch (e) { } };
        function lockPitch() { try { map.setPitch(0); } catch (e) {} try { if (map.on) map.on('move', _enforcePitch); } catch(e) {} pitchLocked = true; pitchBtn.textContent = '斜め許可'; }
        function unlockPitch() { try { if (map.off) map.off('move', _enforcePitch); } catch(e) {} pitchLocked = false; pitchBtn.textContent = '斜め禁止'; }
        pitchBtn.addEventListener('click', function() { if (!pitchLocked) lockPitch(); else unlockPitch(); });
        try { lockPitch(); } catch(e) {}
      } catch (e) { console.warn('pitch toggle setup failed', e); }

    } catch (e) { console.warn('qmap_postload failed', e); }
  };
})();
