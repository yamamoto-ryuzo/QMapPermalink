# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMapPermalink
                                 A QGIS plugin
 Navigate QGIS map views through external permalink system
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-10-05
        git sha              : $Format:%H$
        copyright            : (C) 2025 by yamamoto-ryuzo
        email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QUrl, QThread, pyqtSignal, QObject
from qgis.PyQt.QtGui import QIcon, QDesktopServices, QClipboard
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QApplication, QDockWidget
from qgis.core import QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPointXY, QgsRectangle
try:
    from qgis.core import qgsfunction
except Exception:
    qgsfunction = None

from qgis.gui import QgsMapCanvas

# ユーザー関数を追加（QGIS 環境では qgsfunction デコレータで登録）
if qgsfunction:
    try:
        @qgsfunction(args='auto', group='Custom', usesgeometry=False)
        def my_custom_function(value1, value2, feature, parent):
            return value1 + value2
    except Exception:
        # 登録失敗しても通常の関数は定義しておく
        def my_custom_function(value1, value2, feature, parent):
            return value1 + value2
else:
    # QGIS 環境でない場合はデコレータなしで定義
    def my_custom_function(value1, value2, feature, parent):
        return value1 + value2

import os.path
import json
import urllib.parse
import threading
import socket
import math
import html

# パネルファイルのインポート
try:
    from .qmap_permalink_panel import QMapPermalinkPanel
    PANEL_AVAILABLE = True
except ImportError:
    try:
        # 簡易版をバックアップとして試行
        from .qmap_permalink_panel_simple import SimpleQMapPermalinkPanel as QMapPermalinkPanel
        PANEL_AVAILABLE = True
    except ImportError:
        PANEL_AVAILABLE = False
        QMapPermalinkPanel = None


class NavigationSignals(QObject):
    """QGIS APIへの安全なアクセスのためのシグナル"""
    navigate_requested = pyqtSignal(dict)  # 地図ナビゲーション要求


class QMapPermalink:
    """QGISの地図ビューをパーマリンクで管理・ナビゲートするプラグイン"""

    def __init__(self, iface):
        """コンストラクタ

        Args:
            iface: QGISのインターフェースオブジェクト
        """
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        
        # 翻訳の初期化
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QMapPermalink_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # プラグインの宣言
        self.actions = []
        self.menu = self.tr(u'&QMap Permalink')
        
        # パネル（ドックウィジェット）
        self.panel = None

        # HTTPサーバー関連
        self.http_server = None
        self.server_thread = None
        self.server_port = 8089  # デフォルトポート
        self._http_running = False
        self._last_request_text = ""
        
        # ナビゲーション用シグナル
        self.navigation_signals = NavigationSignals()
        self.navigation_signals.navigate_requested.connect(self.handle_navigation_request)

        # ツールバーの確認（初回実行時にツールバーが存在するかチェック）
        self.first_start = None

    def tr(self, message):
        """翻訳を取得
        
        Args:
            message: 翻訳対象のメッセージ
            
        Returns:
            翻訳されたメッセージ
        """
        return QCoreApplication.translate('QMapPermalink', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """ツールバーアイコンやメニューアイテムを追加

        Args:
            icon_path: アイコンファイルのパス
            text: アクションのテキスト
            callback: アクションが実行された時のコールバック関数
            enabled_flag: アクションが有効かどうか
            add_to_menu: メニューに追加するかどうか
            add_to_toolbar: ツールバーに追加するかどうか
            status_tip: ステータスバーに表示するヒント
            whats_this: What's Thisヘルプ
            parent: 親ウィジェット

        Returns:
            作成されたQActionオブジェクト
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # このプラグイン専用のツールバーに追加
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """プラグインのGUI要素を作成（プラグイン読み込み時に呼ばれる）"""
        icon_path = os.path.join(self.plugin_dir, 'icon.png')
        
        # パネル版のアクション
        if PANEL_AVAILABLE:
            self.add_action(
                icon_path,
                text=self.tr(u'QMap Permalink'),
                callback=self.toggle_panel,
                parent=self.iface.mainWindow())
        else:
            # パネルが利用できない場合は警告メッセージ
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available. Please try reinstalling the plugin."),
                level=2,  # WARNING
                duration=10
            )

        # HTTPサーバーを起動
        self.start_http_server()

        # 初回起動フラグ
        self.first_start = True

    def toggle_panel(self):
        """パネルの表示/非表示を切り替え"""
        if not PANEL_AVAILABLE:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available.")
            )
            return
            
        try:
            if self.panel is None:
                # パネル利用可能性をデバッグ
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    f"PANEL_AVAILABLE: {PANEL_AVAILABLE}, QMapPermalinkPanel: {QMapPermalinkPanel}", 
                    duration=5
                )
                
                # パネルを作成
                self.panel = QMapPermalinkPanel(self.iface.mainWindow())
                
                # パネルのボタンにイベントを接続
                self.panel.pushButton_generate.clicked.connect(self.on_generate_clicked_panel)
                self.panel.pushButton_navigate.clicked.connect(self.on_navigate_clicked_panel)
                self.panel.pushButton_copy.clicked.connect(self.on_copy_clicked_panel)
                if hasattr(self.panel, 'pushButton_open'):
                    self.panel.pushButton_open.clicked.connect(self.on_open_clicked_panel)
                
                # HTTPサーバーの状態を更新
                server_running = self.http_server is not None
                self.panel.update_server_status(self.server_port, server_running)
                
                # テーマ一覧を更新
                self.update_theme_list()
                
                # QGISのメインウィンドウの左側にドッキング
                self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.panel)
                
                # 既存の左側パネルがあればタブ化
                self._try_tabify_with_existing_panels()
                
                # デバッグメッセージ
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Panel created successfully."), 
                    duration=3
                )
            else:
                # パネルの表示/非表示を切り替え
                if self.panel.isVisible():
                    self.panel.hide()
                else:
                    self.panel.show()
                    
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to create panel: {error}").format(error=str(e))
            )

    def _try_tabify_with_existing_panels(self):
        """既存の左側パネルがあればタブ化を試行"""
        try:
            # QGISメインウィンドウから左側ドックエリアのウィジェットを取得
            main_window = self.iface.mainWindow()
            
            # よく使われるパネル名のリスト（優先順位順）
            preferred_panels = [
                'Layers',           # レイヤーパネル
                'Browser',          # ブラウザパネル
                'Browser2',         # ブラウザパネル（別名）
                'LayerOrder',       # レイヤー順序パネル
                'Processing',       # プロセシングツールボックス
                'History',          # 履歴パネル
            ]
            
            target_panel = None
            
            # 優先パネルから検索
            for panel_name in preferred_panels:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible() and
                        (panel_name.lower() in widget.objectName().lower() or
                         panel_name.lower() in widget.windowTitle().lower())):
                        target_panel = widget
                        break
                if target_panel:
                    break
            
            # 優先パネルが見つからない場合は左側の最初のパネルを使用
            if not target_panel:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible()):
                        target_panel = widget
                        break
            
            # タブ化実行
            if target_panel:
                main_window.tabifyDockWidget(target_panel, self.panel)
                
                # QMapPermalinkパネルをアクティブにする
                self.panel.raise_()
                
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Tabified with '{panel_name}' panel.").format(panel_name=target_panel.windowTitle()), 
                    duration=3
                )
            else:
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Displayed as an independent panel on the left side."), 
                    duration=3
                )
                
        except Exception as e:
            # タブ化に失敗しても継続
            print(f"パネルのタブ化でエラー: {e}")
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                self.tr("Panel displayed on the left side."), 
                duration=3
            )

    def unload(self):
        """プラグインのアンロード時の処理"""
        # HTTPサーバーを停止
        self.stop_http_server()
        
        # パネルを削除
        if self.panel is not None:
            self.iface.removeDockWidget(self.panel)
            self.panel = None
        
        # シグナルを切断
        if hasattr(self, 'navigation_signals'):
            self.navigation_signals.navigate_requested.disconnect()
        
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QMap Permalink'),
                action)
            self.iface.removeToolBarIcon(action)

    def start_http_server(self):
        """HTTPサーバーを起動"""
        try:
            if self._http_running:
                return

            # 使用可能なポートを探す
            self.server_port = self.find_available_port(8089, 8099)

            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind(('localhost', self.server_port))
            server_socket.listen(5)
            server_socket.settimeout(1.0)

            self.http_server = server_socket
            self._http_running = True

            self.server_thread = threading.Thread(
                target=self.run_server,
                name="QMapPermalinkHTTP",
                daemon=True,
            )
            self.server_thread.start()

            print(f"QMap Permalink HTTPサーバーが起動しました: http://localhost:{self.server_port}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink",
                f"HTTPサーバーが起動しました (ポート: {self.server_port})",
                duration=3
            )

        except Exception as e:
            print(f"HTTPサーバーの起動に失敗しました: {e}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink エラー",
                f"HTTPサーバーの起動に失敗しました: {str(e)}",
                duration=5
            )
            self._http_running = False
            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None
    
    def run_server(self):
        """サーバーを安全に実行"""
        try:
            while self._http_running and self.http_server:
                try:
                    conn, addr = self.http_server.accept()
                except socket.timeout:
                    continue
                except OSError:
                    break

                try:
                    self._handle_client_connection(conn, addr)
                except Exception as e:
                    print(f"HTTPリクエスト処理中にエラーが発生しました: {e}")

        finally:
            self._http_running = False
            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None
            print("HTTPサーバーが停止しました")
    
    def stop_http_server(self):
        """HTTPサーバーを停止"""
        try:
            self._http_running = False

            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None

            # スレッドの終了を待つ
            if self.server_thread and self.server_thread.is_alive():
                try:
                    self.server_thread.join(timeout=3.0)
                except Exception:
                    pass
                self.server_thread = None

            print("QMap Permalink HTTPサーバーが停止しました")
            
        except Exception as e:
            print(f"HTTPサーバーの停止中にエラーが発生しました: {e}")

    def _handle_client_connection(self, conn, addr):
        """HTTPリクエストを解析して必要であればナビゲーションを実行"""
        with conn:
            request_bytes = self._read_http_request(conn)
            if not request_bytes:
                return

            request_text = request_bytes.decode('iso-8859-1', errors='replace')
            self._last_request_text = request_text

            print("QMap Permalink HTTP request from", addr)
            print(request_text)

            try:
                request_line = request_text.splitlines()[0]
            except IndexError:
                self._send_http_response(conn, 400, "Bad Request", "Invalid HTTP request line.")
                return

            parts = request_line.split()
            if len(parts) < 3:
                self._send_http_response(conn, 400, "Bad Request", "Malformed HTTP request line.")
                return

            method, target, _ = parts

            if method.upper() != 'GET':
                self._send_http_response(conn, 405, "Method Not Allowed", "Only GET is supported.")
                return

            parsed_url = urllib.parse.urlparse(target)

            if parsed_url.path != '/qgis-map':
                self._send_http_response(conn, 404, "Not Found", "Endpoint not found.")
                return

            params = urllib.parse.parse_qs(parsed_url.query)

            try:
                navigation_data = self._build_navigation_data_from_params(params)
            except ValueError as e:
                self._send_http_response(conn, 400, "Bad Request", str(e))
                return

            # メインスレッドでナビゲーションを実行
            self.navigation_signals.navigate_requested.emit(navigation_data)

            google_url = self._build_google_maps_url(navigation_data)
            if google_url:
                escaped_url = html.escape(google_url)
                body = (
                    "<!DOCTYPE html>"
                    "<html lang=\"ja\">"
                    "<head>"
                    "<meta charset=\"utf-8\">"
                    "<title>QMap Permalink</title>"
                    "</head>"
                    "<body>"
                    "<p>地図の移動を受け付けました。Google Mapsでも同じ地点を開けます:</p>"
                    "<p><a href=\"" + escaped_url + "\" target=\"_blank\" rel=\"noopener noreferrer\">" + escaped_url + "</a></p>"
                    "</body>"
                    "</html>"
                )
                self._send_http_response(conn, 200, "OK", body, "text/html; charset=utf-8")
            else:
                body = (
                    "<!DOCTYPE html>"
                    "<html lang=\"ja\">"
                    "<head><meta charset=\"utf-8\"><title>QMap Permalink</title></head>"
                    "<body><p>地図の移動を受け付けました。</p></body>"
                    "</html>"
                )
                self._send_http_response(conn, 200, "OK", body, "text/html; charset=utf-8")
        
    def _build_navigation_data_from_params(self, params):
        """HTTPクエリパラメータからナビゲーション用データを生成

        scale を受け取り、ナビゲーションデータに含める。
        zoom は明示的に指定されている場合のみ navigation_data に含まれる。
        """
        if 'location' in params:
            raw_location = params['location'][0]
            navigation_data = {
                'type': 'location',
                'location': raw_location,
            }
            try:
                decoded = urllib.parse.unquote(raw_location)
                data = json.loads(decoded)
                lat = data.get('center_wgs84_lat')
                lon = data.get('center_wgs84_lon')
                if lat is not None and lon is not None:
                    navigation_data['lat'] = float(lat)
                    navigation_data['lon'] = float(lon)
                if 'zoom_level' in data:
                    navigation_data['zoom'] = float(data['zoom_level'])
                navigation_data['crs'] = data.get('crs', 'EPSG:4326')
                navigation_data['center_x'] = data.get('center_x')
                navigation_data['center_y'] = data.get('center_y')
                # scale は数値のまま渡す
                navigation_data['scale'] = data.get('scale')
                navigation_data['map_units_per_pixel'] = data.get('map_units_per_pixel')
            except Exception:
                pass
            return navigation_data

        crs = params.get('crs', ['EPSG:4326'])[0]
        zoom_value = self._extract_zoom(params)
        # scale パラメータがあればナビゲーションデータに含める
        scale_value = None
        # rotation パラメータがあれば含める
        rotation_value = None
        # theme パラメータがあれば処理
        theme_info = None
        if 'scale' in params:
            try:
                scale_value = float(params['scale'][0])
            except Exception:
                raise ValueError("scale パラメータは数値で指定してください")
        if 'rotation' in params:
            try:
                rotation_value = float(params['rotation'][0])
            except Exception:
                raise ValueError("rotation パラメータは数値で指定してください")
        if 'theme' in params:
            try:
                theme_encoded = params['theme'][0]
                theme_name = urllib.parse.unquote(theme_encoded)
                # シンプルにテーマ名を保存
                theme_info = theme_name
            except Exception as e:
                print(f"テーマパラメータの解析エラー: {e}")
                # エラーでも処理を続行

        if 'll' in params:
            lat, lon = self._parse_latlon(params['ll'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if 'q' in params:
            lat, lon = self._parse_latlon(params['q'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if 'center' in params:
            lat, lon = self._parse_latlon(params['center'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
            }

    # 新仕様: シンプルな x/y/scale パラメータをサポート（標準は scale）
    # 例（緯度経度）: /qgis-map?x=139&y=35&scale=1000.0&crs=EPSG:4326 (デフォルト crs=EPSG:4326)
    # 例（直角座標、例として EPSG:6677）: /qgis-map?x=667700.0&y=4321987.0&scale=1000.0&crs=EPSG:6677
        if 'x' in params and 'y' in params:
            try:
                x_val = float(params['x'][0])
                y_val = float(params['y'][0])
            except Exception:
                raise ValueError("x/y パラメータは数値で指定してください")
            # 緯度経度として扱う場合（デフォルト CRS が EPSG:4326）には lat/lon を設定
            lat_val = None
            lon_val = None
            if crs.upper().startswith('EPSG:4326'):
                lat_val = float(y_val)
                lon_val = float(x_val)
            return {
                'type': 'coordinates',
                'x': x_val,
                'y': y_val,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat_val,
                'lon': lon_val,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if all(key in params for key in ('lat', 'lon')):
            try:
                lat = float(params['lat'][0])
                lon = float(params['lon'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid lat/lon parameters.")
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
            }

        if all(key in params for key in ('lat', 'lng')):
            try:
                lat = float(params['lat'][0])
                lon = float(params['lng'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid lat/lng parameters.")
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
            }

        if all(key in params for key in ('x', 'y')):
            try:
                x_value = float(params['x'][0])
                y_value = float(params['y'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid coordinate parameters.")
            data = {
                'type': 'coordinates',
                'x': x_value,
                'y': y_value,
                'zoom': zoom_value,
                'crs': crs,
            }
            if crs.upper() == 'EPSG:4326':
                data['lat'] = y_value
                data['lon'] = x_value
            data['scale'] = scale_value
            data['rotation'] = rotation_value
            return data

        raise ValueError("Missing required parameters.")

    def _read_http_request(self, conn):
        """HTTPリクエスト全体を読み取る"""
        data = b""
        conn.settimeout(2.0)

        while True:
            try:
                chunk = conn.recv(1024)
            except socket.timeout:
                break

            if not chunk:
                break

            data += chunk

            if b"\r\n\r\n" in data:
                break

        return data

    def _send_http_response(self, conn, status_code, reason, body, content_type="text/plain; charset=utf-8"):
        """最小限のHTTPレスポンスを送信"""
        if isinstance(body, str):
            body_bytes = body.encode('utf-8')
        else:
            body_bytes = body

        header_lines = [
            f"HTTP/1.1 {status_code} {reason}",
            f"Content-Length: {len(body_bytes)}",
            f"Content-Type: {content_type}",
            "Connection: close",
            "",
            "",
        ]

        header_bytes = "\r\n".join(header_lines).encode('utf-8')

        try:
            conn.sendall(header_bytes + body_bytes)
        except OSError:
            pass

    def _extract_zoom(self, params):
        """クエリパラメータからズームレベルを取得

        明示的なズーム指定がなければ None を返す（Google 用に scale から推定する）
        """
        for key in ('z', 'zoom', 'level'):
            if key in params:
                try:
                    return float(params[key][0])
                except (TypeError, ValueError):
                    raise ValueError(f"Invalid {key} parameter.")
        return None

    def _build_google_maps_url(self, navigation_data):
        """ナビゲーションデータからGoogle Maps用URLを生成

        Google Maps用は zoom が必要。zoom が与えられなければ scale から推定する。
        最終フォールバックは zoom=16 とする。
        """
        try:
            if navigation_data.get('type') == 'coordinates':
                lat, lon = self._resolve_coordinates(navigation_data)
                if lat is None or lon is None:
                    return None
                # zoom が無ければ scale から推定し、無ければデフォルト16を使う
                zoom_value = navigation_data.get('zoom')
                if zoom_value is None:
                    zoom_value = self._estimate_zoom_from_scale(navigation_data.get('scale'))
                if zoom_value is None:
                    zoom_value = 16.0
                zoom_int = max(0, int(round(float(zoom_value))))
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_int}z"

            if navigation_data.get('type') == 'location':
                lat = navigation_data.get('lat')
                lon = navigation_data.get('lon')
                zoom_value = navigation_data.get('zoom')

                if lat is None or lon is None:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                    except Exception:
                        data = {}

                    if data:
                        center_lat = data.get('center_wgs84_lat')
                        center_lon = data.get('center_wgs84_lon')
                        if center_lat is not None and center_lon is not None:
                            lat = float(center_lat)
                            lon = float(center_lon)
                        else:
                            center_x = data.get('center_x')
                            center_y = data.get('center_y')
                            crs_authid = data.get('center_crs') or data.get('crs')
                            if center_x is not None and center_y is not None and crs_authid:
                                lat, lon = self._convert_to_wgs84(center_x, center_y, crs_authid)
                        if zoom_value is None:
                            zoom_value = self._estimate_zoom_from_scale(data.get('scale'))

                if (lat is None or lon is None) and navigation_data.get('center_x') is not None:
                    crs_authid = navigation_data.get('crs')
                    lat, lon = self._convert_to_wgs84(
                        navigation_data.get('center_x'),
                        navigation_data.get('center_y'),
                        crs_authid,
                    )

                if lat is None or lon is None:
                    return None

                if zoom_value is None:
                    zoom_value = 16.0

                zoom_int = max(0, int(round(float(zoom_value))))
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_int}z"

        except Exception:
            return None

        return None

    def _resolve_coordinates(self, navigation_data):
        """ナビゲーションデータからWGS84座標を求める"""
        lat = navigation_data.get('lat')
        lon = navigation_data.get('lon')
        if lat is not None and lon is not None:
            return float(lat), float(lon)

        x = navigation_data.get('x')
        y = navigation_data.get('y')
        crs_authid = navigation_data.get('crs')
        if x is None or y is None or crs_authid is None:
            return None, None

        return self._convert_to_wgs84(x, y, crs_authid)


    def _estimate_zoom_from_scale(self, scale):
        """スケール値からGoogle Maps用ズームレベルを推定（QGISスケール感覚対応版改良）
        
        QGISの実際のスケール表示に合わせた固定テーブル方式を使用します。
        「ズームレベルが小さく表示される」問題を改善するため、詳細スケールでズームレベルを上げています。
        """
        if not scale:
            return 16.0
        try:
            s = float(scale)
            if s <= 0:
                return 16.0

            # QGIS実スケール対応の改良版固定スケールテーブル
            # 詳細スケール（1:500〜1:25000）で+1〜2ズームレベル上げて調整
            scale_table = {
                0: 400_000_000.0, 1: 200_000_000.0, 2: 100_000_000.0, 3: 60_000_000.0, 4: 30_000_000.0,
                5: 15_000_000.0, 6: 8_000_000.0, 7: 4_000_000.0, 8: 2_000_000.0, 9: 1_000_000.0,
                # 中〜詳細スケールを高ズーム方向に調整
                10: 600_000.0,    # 元: 400_000.0 → より詳細に
                11: 300_000.0,    # 元: 200_000.0 → より詳細に
                12: 150_000.0,    # 元: 100_000.0 → より詳細に
                13: 75_000.0,     # 元: 40_000.0 → 大幅に詳細化
                14: 40_000.0,     # 元: 20_000.0 → 2倍詳細
                15: 20_000.0,     # 元: 10_000.0 → 2倍詳細
                16: 10_000.0,     # 元: 5_000.0 → 2倍詳細
                17: 5_000.0,      # 元: 2_500.0 → 2倍詳細
                18: 2_500.0,      # 元: 1_250.0 → 2倍詳細
                19: 1_250.0,      # 元: 600.0 → 大幅に詳細化
                20: 600.0,        # 元: 300.0 → 2倍詳細
                21: 300.0,        # 元: 150.0 → 2倍詳細
                22: 150.0,        # 元: 75.0 → 2倍詳細
                23: 75.0,         # 元: 40.0 → やや詳細に
            }

            # 外挿: 24-30 は 23 の値を半分ずつ外挿
            for z in range(24, 31):
                scale_table[z] = scale_table[23] / (2 ** (z - 23))

            # 比較は対数空間（スケールの比率差）で行う方が自然
            target_log = math.log(s)
            best_zoom = 16
            best_diff = None
            for z, zscale in scale_table.items():
                diff = abs(math.log(zscale) - target_log)
                if best_diff is None or diff < best_diff:
                    best_diff = diff
                    best_zoom = z

            # clamp 0..30
            return max(0, min(30, int(best_zoom)))
        except (ValueError, TypeError, OverflowError):
            return 16.0

    def _convert_to_wgs84(self, x, y, source_crs_authid):
        """任意座標をWGS84へ変換"""
        try:
            source_crs = QgsCoordinateReferenceSystem(str(source_crs_authid))
            if not source_crs.isValid():
                return None, None
            target_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            point = transform.transform(QgsPointXY(float(x), float(y)))
            return float(point.y()), float(point.x())
        except Exception:
            return None, None

    def find_available_port(self, start_port, end_port):
        """使用可能なポートを探す
        
        Args:
            start_port: 開始ポート番号
            end_port: 終了ポート番号
            
        Returns:
            使用可能なポート番号
        """
        for port in range(start_port, end_port + 1):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('localhost', port))
                    return port
            except OSError:
                continue
        raise RuntimeError(f"ポート範囲 {start_port}-{end_port} で使用可能なポートが見つかりません")
    
    def generate_permalink(self, include_theme=True, specific_theme=None):
        """現在の地図ビューからパーマリンクを生成
        
        Args:
            include_theme (bool): テーマ情報を含めるかどうか
            specific_theme (str): 指定するテーマ名（None の場合は現在の状態を使用）
        
        Returns:
            パーマリンクURL文字列（HTTP形式）
        """
        # 現在のマップキャンバス情報を取得
        canvas = self.iface.mapCanvas()
        extent = canvas.extent()
        crs = canvas.mapSettings().destinationCrs()
        scale = canvas.scale()
        # 回転角度（度）
        rotation = canvas.rotation() if hasattr(canvas, 'rotation') else 0.0
        map_units_per_pixel = canvas.mapUnitsPerPixel()
        center_point = QgsPointXY(
            (extent.xMinimum() + extent.xMaximum()) / 2.0,
            (extent.yMinimum() + extent.yMaximum()) / 2.0,
        )

        # スケールからズームレベルを推定（Web標準対応でより正確）
        zoom_level = self._estimate_zoom_from_scale(scale)

        # 基本パラメータを構築
        x_val = f"{center_point.x():.6f}"
        y_val = f"{center_point.y():.6f}"
        crs_id = crs.authid()  # e.g. 'EPSG:3857' or 'EPSG:4326'
        # scale はキャンバスの scale() を使う
        scale_val = float(scale) if scale is not None else None
        if scale_val is None:
            # 万が一 scale が取得できなければ、ズームレベルから推定して scale を算出（逆算は簡易）
            # ここでは推定値として 1000 を入れておく
            scale_val = 1000.0
        
        # 基本URL構築
        permalink_url = (
            f"http://localhost:{self.server_port}/qgis-map?x={x_val}&y={y_val}"
            f"&scale={scale_val:.1f}&crs={crs_id}&rotation={rotation:.2f}"
        )
        
        # テーマ情報を追加（オプション）
        if include_theme and specific_theme:
            # シンプルなテーマ名をパラメータに追加
            theme_encoded = urllib.parse.quote(specific_theme)
            permalink_url += f"&theme={theme_encoded}"
        
        return permalink_url

    def navigate_to_permalink(self, permalink_url):
        """パーマリンクURLから地図ビューに移動
        
        Args:
            permalink_url: パーマリンクURL
        """
        try:
            # HTTP形式のURLを処理
            if permalink_url.startswith('http://localhost:') and '/qgis-map' in permalink_url:
                # HTTP URLから直接実行（ブラウザを経由しない）
                parsed_url = urllib.parse.urlparse(permalink_url)
                params = urllib.parse.parse_qs(parsed_url.query)

                # パラメータをナビゲーションデータへ変換して処理（location または coordinates をサポート）
                try:
                    navigation_data = self._build_navigation_data_from_params(params)
                except ValueError as e:
                    raise

                if navigation_data.get('type') == 'location':
                    # エンコード済み location JSON を処理
                    self.navigate_from_http(navigation_data['location'])
                elif navigation_data.get('type') == 'coordinates':
                    x = navigation_data.get('x')
                    y = navigation_data.get('y')
                    zoom = navigation_data.get('zoom')
                    scale = navigation_data.get('scale')
                    crs = navigation_data.get('crs')
                    rotation = navigation_data.get('rotation')
                    theme_info = navigation_data.get('theme_info')
                    # 直接移動を実行（scale を優先）
                    self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                else:
                    raise ValueError("HTTP URLのパラメータからナビゲーションデータを生成できませんでした。")
                    
            # 従来のカスタムプロトコル形式も維持
            elif permalink_url.startswith('qgis-permalink://'):
                encoded_data = permalink_url[17:]  # "qgis-permalink://"を除去
                json_data = urllib.parse.unquote(encoded_data)
                permalink_data = json.loads(json_data)
                
                # 座標系とextentを復元
                crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
                extent = QgsRectangle(
                    permalink_data['x_min'],
                    permalink_data['y_min'],
                    permalink_data['x_max'],
                    permalink_data['y_max']
                )
                
                # マップキャンバスに適用
                canvas = self.iface.mapCanvas()
                canvas.setDestinationCrs(crs)
                canvas.setExtent(extent)
                canvas.refresh()
                
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    "パーマリンクから地図ビューに移動しました。", 
                    duration=3
                )
                
            else:
                raise ValueError("サポートされていないパーマリンクURL形式です。")
                
        except Exception as e:
            QMessageBox.warning(
                self.iface.mainWindow(),
                "QMap Permalink エラー",
                f"パーマリンクの処理中にエラーが発生しました：\n{str(e)}"
            )
    
    def navigate_from_http(self, location_data):
        """HTTP経由でのナビゲーション処理
        
        Args:
            location_data: エンコードされた位置データ
        """
        try:
            # URLデコードしてJSONパース
            json_data = urllib.parse.unquote(location_data)
            permalink_data = json.loads(json_data)
            
            # 座標系とextentを復元
            crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
            extent = QgsRectangle(
                permalink_data['x_min'],
                permalink_data['y_min'],
                permalink_data['x_max'],
                permalink_data['y_max']
            )
            
            # マップキャンバスに適用
            canvas = self.iface.mapCanvas()
            canvas.setDestinationCrs(crs)
            canvas.setExtent(extent)
            canvas.refresh()
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                "HTTP経由で地図ビューに移動しました。", 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"HTTP地図移動の処理中にエラーが発生しました: {str(e)}")
    
    def navigate_to_coordinates(self, x, y, scale, zoom, crs_auth_id, rotation=None, theme_info=None):
        """座標指定でのナビゲーション処理
        
        Args:
            x: 経度またはX座標
            y: 緯度またはY座標  
            zoom: ズームレベル
            crs_auth_id: 座標系ID (例: "EPSG:4326")
            rotation: 回転角度（度）
            theme_info: テーマ情報（辞書）
        """
        try:
            # 座標系を設定
            crs = QgsCoordinateReferenceSystem(crs_auth_id)

            # scale があればそれを優先して、QGIS のキャンバス API に scale をそのまま適用する
            # ここでは明示的なスケール変換は行わず、canvas.zoomScale を使ってシンプルに反映する
            scale_val = None
            if scale is not None:
                try:
                    scale_val = float(scale)
                except Exception:
                    scale_val = None

            # scale が無ければ zoom から簡易推定する（従来の互換用）
            if scale_val is None and zoom is not None:
                try:
                    zoom_val = float(zoom)
                    scale_val = 1000.0 / (2 ** (zoom_val - 10))
                except Exception:
                    scale_val = None

            # 最終フォールバック
            if scale_val is None:
                scale_val = 1000.0

            # マップキャンバスに適用
            canvas = self.iface.mapCanvas()
            canvas.setDestinationCrs(crs)

            try:
                # 中心点を設定してからスケールを適用する（QGIS 側で正しい表示範囲が計算される）
                canvas.setCenter(QgsPointXY(float(x), float(y)))
                canvas.zoomScale(float(scale_val))
                # 回転が指定されていれば適用
                if rotation is not None:
                    try:
                        canvas.setRotation(float(rotation))
                    except Exception:
                        pass
            except Exception:
                # 万が一 canvas の API が使えない/失敗した場合は従来の範囲設定にフォールバック
                half_width = float(scale_val) / 2.0
                half_height = float(scale_val) / 2.0
                extent = QgsRectangle(
                    float(x) - half_width,
                    float(y) - half_height,
                    float(x) + half_width,
                    float(y) + half_height
                )
                canvas.setExtent(extent)

            # テーマ情報がある場合は適用
            theme_applied = False
            if theme_info:
                try:
                    theme_applied = self._apply_theme_from_permalink(theme_info)
                    if theme_applied:
                        print("テーマが正常に適用されました")
                except Exception as e:
                    print(f"テーマ適用エラー: {e}")
            
            canvas.refresh()
            
            # メッセージを表示
            message = f"座標 ({x:.6f}, {y:.6f}) に移動しました。"
            if theme_applied:
                message += " テーマも復元されました。"
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                message, 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"座標移動の処理中にエラーが発生しました: {str(e)}")

    # パネル用のイベントハンドラ

    def handle_navigation_request(self, navigation_data):
        """HTTPリクエストからのナビゲーション要求を安全に処理（メインスレッドで実行）
        
        Args:
            navigation_data: ナビゲーション情報を含む辞書
        """
        try:
            if navigation_data['type'] == 'location':
                # JSON形式のlocationデータを処理
                location_data = navigation_data['location']
                self.navigate_from_http(location_data)
            elif navigation_data['type'] == 'coordinates':
                # 個別座標パラメータを処理
                x = navigation_data['x']
                y = navigation_data['y']
                zoom = navigation_data.get('zoom')
                scale = navigation_data.get('scale')
                crs = navigation_data['crs']
                rotation = navigation_data.get('rotation')
                theme_info = navigation_data.get('theme_info')
                # scale を優先して渡す（None の場合は zoom を使う）
                self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                
            print(f"ナビゲーション完了: {navigation_data['type']}")
            
        except Exception as e:
            print(f"ナビゲーション処理エラー: {e}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink エラー", 
                f"ナビゲーション処理中にエラーが発生しました: {str(e)}", 
                duration=5
            )
    


    # パネル用のイベントハンドラ
    def on_generate_clicked_panel(self):
        """パネル版：パーマリンク生成ボタンがクリックされた時の処理"""
        try:
            # ドロップダウンの選択からテーマ設定を判定
            include_theme = False
            specific_theme = None
            
            if hasattr(self.panel, 'comboBox_themes'):
                selected_option = self.panel.comboBox_themes.currentText()
                
                if selected_option == "-- No Theme (Position Only) --":
                    include_theme = False
                    specific_theme = None
                elif selected_option:  # 実際のテーマ名が選択された場合
                    include_theme = True
                    specific_theme = selected_option
            
            permalink = self.generate_permalink(include_theme=include_theme, specific_theme=specific_theme)
            self.panel.lineEdit_permalink.setText(permalink)
            
            # メッセージにテーマ情報の有無を含める
            if include_theme and specific_theme:
                message = self.tr("Permalink with theme '{theme}' generated successfully.").format(theme=specific_theme)
            else:
                message = self.tr("Permalink (position only) generated successfully.")
            
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                message, 
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to generate permalink: {error}").format(error=str(e))
            )

    def on_navigate_clicked_panel(self):
        """パネル版：ナビゲートボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_navigate.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Please enter a permalink URL.")
            )
            return
            
        self.navigate_to_permalink(permalink_url)

    def on_copy_clicked_panel(self):
        """パネル版：コピーボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to copy.")
            )
            return
            
        clipboard = QApplication.clipboard()
        success = False

        for _ in range(3):
            clipboard.setText(permalink_url, mode=QClipboard.Clipboard)
            QApplication.processEvents()
            if clipboard.text(mode=QClipboard.Clipboard) == permalink_url:
                if clipboard.supportsSelection():
                    clipboard.setText(permalink_url, mode=QClipboard.Selection)
                success = True
                break
            QThread.msleep(50)

        if success:
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink copied to clipboard."),
                duration=3
            )
        else:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to copy to clipboard. Please try again or copy manually.")
            )

    def on_open_clicked_panel(self):
        """パネル版：ブラウザで開くボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to open.")
            )
            return
            
        try:
            QDesktopServices.openUrl(QUrl(permalink_url))
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink opened in browser."),
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to open in browser: {error}").format(error=str(e))
            )

    # テーマ関連のメソッド群
    
    def _get_current_theme_info(self):
        """現在のテーマ情報を取得（無効化 - 複雑すぎるため）
        
        Returns:
            None: 常にNoneを返す（機能無効化）
        """
        # 複雑すぎて安定しないため、この機能を無効化
        return None
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return None
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return None
            
            # 現在のレイヤー状態を取得
            layer_states = self._get_current_layer_states()
            
            # アクティブなテーマがあるかチェック
            current_theme = self._detect_current_theme(theme_collection, layer_states)
            
            theme_info = {
                'version': '1.0',
                'current_theme': current_theme,
                'layer_states': layer_states,
                'available_themes': theme_collection.mapThemes()
            }
            
            return theme_info
            
        except ImportError:
            # QGISが利用できない環境
            return None
        except Exception as e:
            print(f"テーマ情報取得エラー: {e}")
            return None
    
    def _get_current_layer_states(self):
        """現在のレイヤー状態を取得
        
        Returns:
            dict: レイヤー状態情報
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeLayer, QgsLayerTreeGroup
            
            project = QgsProject.instance()
            root = project.layerTreeRoot()
            
            layer_states = {}
            
            def collect_layer_info(node, path=""):
                """レイヤーノードから情報を再帰的に収集"""
                if isinstance(node, QgsLayerTreeLayer):
                    layer = node.layer()
                    if layer:
                        layer_id = layer.id()
                        layer_states[layer_id] = {
                            'name': layer.name(),
                            'visible': node.isVisible(),
                            'expanded': node.isExpanded(),
                            'opacity': getattr(layer, 'opacity', lambda: 1.0)(),
                            'path': path,
                            'type': layer.type().name if hasattr(layer.type(), 'name') else str(layer.type())
                        }
                        
                        # スタイル情報も含める（可能であれば）
                        if hasattr(layer, 'styleManager'):
                            try:
                                current_style = layer.styleManager().currentStyle()
                                layer_states[layer_id]['current_style'] = current_style
                                layer_states[layer_id]['available_styles'] = layer.styleManager().styles()
                            except:
                                pass
                                
                elif isinstance(node, QgsLayerTreeGroup):
                    group_path = f"{path}/{node.name()}" if path else node.name()
                    layer_states[f"group:{node.name()}"] = {
                        'name': node.name(),
                        'type': 'group',
                        'visible': node.isVisible(),
                        'expanded': node.isExpanded(),
                        'path': path
                    }
                    
                    # 子要素を再帰的に処理
                    for child in node.children():
                        collect_layer_info(child, group_path)
            
            # ルートから開始
            for child in root.children():
                collect_layer_info(child)
            
            return layer_states
            
        except Exception as e:
            print(f"レイヤー状態取得エラー: {e}")
            return {}
    
    def _detect_current_theme(self, theme_collection, current_layer_states):
        """現在の状態に最も近いテーマを検出
        
        Args:
            theme_collection: QgsMapThemeCollection
            current_layer_states: 現在のレイヤー状態
            
        Returns:
            str or None: テーマ名、または一致するものがない場合はNone
        """
        try:
            available_themes = theme_collection.mapThemes()
            
            for theme_name in available_themes:
                # テーマの状態と現在の状態を比較
                # 実際の詳細比較は複雑になるため、簡単な一致判定を行う
                
                # ここでは簡単な実装として、テーマ名による判定のみ行う
                # 実際の実装では、レイヤーの表示状態やスタイルを詳細に比較する必要がある
                pass
            
            # 簡略化：現在は常にNoneを返す（完全一致の検出は複雑なため）
            return None
            
        except Exception as e:
            print(f"テーマ検出エラー: {e}")
            return None
    
    def _apply_theme_from_permalink(self, theme_name):
        """パーマリンクからテーマを復元・適用
        
        Args:
            theme_name (str): テーマ名
            
        Returns:
            bool: 適用成功かどうか
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeModel
            
            if not theme_name or not isinstance(theme_name, str):
                return False
            
            project = QgsProject.instance()
            if not project:
                return False
            
            # 指定されたテーマを適用
            theme_collection = project.mapThemeCollection()
            if theme_name in theme_collection.mapThemes():
                root = project.layerTreeRoot()
                model = QgsLayerTreeModel(root)
                theme_collection.applyTheme(theme_name, root, model)
                return True
            
            return False
            
        except ImportError:
            # QGISが利用できない環境
            return False
        except Exception as e:
            print(f"テーマ適用エラー: {e}")
            return False
    

    def update_theme_list(self):
        """パネルのテーマ一覧を更新"""
        if not self.panel or not hasattr(self.panel, 'comboBox_themes'):
            return
            
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return
            
            # コンボボックスをクリア
            self.panel.comboBox_themes.clear()
            
            # システムオプションを追加
            self.panel.comboBox_themes.addItem("-- No Theme (Position Only) --")
            
            # 利用可能なテーマを追加
            available_themes = theme_collection.mapThemes()
            for theme_name in sorted(available_themes):
                self.panel.comboBox_themes.addItem(theme_name)
                
            print(f"テーマ一覧を更新: {len(available_themes)} テーマが見つかりました")
            
        except ImportError:
            # QGISが利用できない環境
            print("QGIS環境が利用できません")
        except Exception as e:
            print(f"テーマ一覧更新エラー: {e}")


