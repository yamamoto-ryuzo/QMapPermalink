# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMapPermalink
                                 A QGIS plugin
 Navigate QGIS map views through external permalink system
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-10-05
        git sha              : $Format:%H$
        copyright            : (C) 2025 by yamamoto-ryuzo
        email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QUrl, QThread, pyqtSignal, QObject

# Qt6 enum compatibility shim: some enums are scoped under classes in Qt6
# (for example DockWidgetArea). Provide legacy attribute names if missing so
# code using Qt.LeftDockWidgetArea continues to work on both Qt5 and Qt6.
try:
    if not hasattr(Qt, 'LeftDockWidgetArea'):
        try:
            Qt.LeftDockWidgetArea = Qt.DockWidgetArea.LeftDockWidgetArea
            Qt.RightDockWidgetArea = Qt.DockWidgetArea.RightDockWidgetArea
        except Exception:
            pass
except Exception:
    pass
from qgis.PyQt.QtGui import QIcon, QDesktopServices, QClipboard
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QApplication, QDockWidget
from qgis.core import QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPointXY, QgsRectangle
try:
    from qgis.core import qgsfunction
except Exception:
    qgsfunction = None

from qgis.gui import QgsMapCanvas

# --- 標準ライブラリのインポート（欠落しているため追加）
import os
import re
import urllib.parse
import math
import json
import traceback

# Optional components: if UI/webmap modules are not present, provide safe defaults
# Try to import optional UI and webmap generator modules; fall back safely when absent.
try:
    from .qmap_permalink_panel import QMapPermalinkPanel  # type: ignore
    PANEL_AVAILABLE = True
    PANEL_IMPORT_ERROR = None
except Exception:
    QMapPermalinkPanel = None
    PANEL_AVAILABLE = False
    import traceback as _tb
    # Capture the import error details for diagnostics in QGIS Python Console
    try:
        PANEL_IMPORT_ERROR = _tb.format_exc()
    except Exception:
        PANEL_IMPORT_ERROR = 'Failed to capture panel import error.'

try:
    from .qmap_webmap_generator import QMapWebMapGenerator  # type: ignore
    WEBMAP_AVAILABLE = True
except Exception:
    QMapWebMapGenerator = None
    WEBMAP_AVAILABLE = False

# ユーザー関数定義（デコレータでの自動登録は import 時に QGIS の内部で
# Cレベルの処理を行うため、環境によってはプロセスがクラッシュすることがある。
# 安全性のためここではデコレータを使わず通常の関数として定義する。必要なら
# プラグイン初期化時に明示的に登録処理を行う。）
def my_custom_function(value1, value2, feature, parent):
    """単純なサンプル関数（登録は行わない）

    NOTE: QGIS の qgsfunction デコレータでの自動登録はここでは行いません。
    もしプラグイン実行環境でユーザー関数の登録が必要であれば、
    initGui() 内など安全なタイミングで登録処理を追加してください。
    """
    try:
        return value1 + value2
    except Exception:
        # 安全に失敗して None を返すだけにする
        return None


class NavigationSignals(QObject):
    """プラグイン内で使用するシンプルなシグナルコンテナ"""
    navigate_requested = pyqtSignal(dict)  # 地図ナビゲーション要求
    # ブラウザから送られてきた完全なURLを通知するシグナル
    request_origin_changed = pyqtSignal(str)


class QMapPermalink:
    """QGISの地図ビューをパーマリンクで管理・ナビゲートするプラグイン"""

    def __init__(self, iface):
        """コンストラクタ

        Args:
            iface: QGISのインターフェースオブジェクト
        """
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        
        # 翻訳の初期化
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QMapPermalink_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # プラグインの宣言
        self.actions = []
        self.menu = self.tr(u'&QMap Permalink')
        
        # パネル（ドックウィジェット）
        self.panel = None

        # ナビゲーション用シグナル
        self.navigation_signals = NavigationSignals()
        self.navigation_signals.navigate_requested.connect(self.handle_navigation_request)
        # 要求元URLを受け取ってUIを更新するハンドラを接続
        try:
            self.navigation_signals.request_origin_changed.connect(self.handle_request_origin_changed)
        except Exception:
            pass

        # WebMap生成器の初期化
        if WEBMAP_AVAILABLE and QMapWebMapGenerator:
            # pass plugin instance (self) so the generator can reuse
            # plugin utilities like _estimate_zoom_from_scale when available
            try:
                self.webmap_generator = QMapWebMapGenerator(self)
            except Exception:
                # fallback to passing iface if plugin instance cannot be used
                self.webmap_generator = QMapWebMapGenerator(self.iface)
        else:
            self.webmap_generator = None

        # HTTPサーバーマネージャー
        from .qmap_permalink_server_manager import QMapPermalinkServerManager
        
        self.server_manager = QMapPermalinkServerManager(
            self.iface, 
            self.navigation_signals, 
            self.webmap_generator,
            self  # メインプラグインインスタンスを渡す
        )
        
        # 高速サーバーマネージャー (オプション)
        try:
            from .bbox import BBoxServerManager
            self.bbox_manager = BBoxServerManager(self.plugin_dir)
            print(f"BBoxServerManager initialized successfully: {self.bbox_manager}")
        except Exception as e:
            self.bbox_manager = None
            print(f"Failed to initialize BBoxServerManager: {e}")
            import traceback
            traceback.print_exc()
        
        # 後方互換性のための一時的な属性(削除予定)
        # server_portアトリビュートエラーを回避
        self.server_port = 8089

        # ツールバーの確認（初回実行時にツールバーが存在するかチェック）
        self.first_start = None

        # 最終的に受信した要求元のURLを保持（パネル未生成時のフォールバック用）
        self._last_request_origin = None

    def handle_request_origin_changed(self, origin):
        """サーバから受け取った完全URLをパネルのlineEdit_navigateにセットする

        origin (str): 例: 'http://localhost:8089/qgis-map?x=...'
        """
        try:
            # 最終値を保持
            self._last_request_origin = origin
            if self.panel and hasattr(self.panel, 'lineEdit_navigate'):
                try:
                    self.panel.lineEdit_navigate.setText(origin)
                except Exception:
                    pass
            # If external control is enabled, automatically navigate to the origin URL
            try:
                if self.panel and getattr(self.panel, 'checkBox_external_control', None) is not None:
                    try:
                        if self.panel.checkBox_external_control.isChecked():
                            # perform navigation automatically
                            if origin:
                                self.navigate_to_permalink(origin)
                    except Exception:
                        # defensive: ignore any navigation errors here
                        pass
            except Exception:
                pass
        except Exception:
            pass

    def tr(self, message):
        """翻訳を取得
        
        Args:
            message: 翻訳対象のメッセージ
            
        Returns:
            翻訳されたメッセージ
        """
        return QCoreApplication.translate('QMapPermalink', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """ツールバーアイコンやメニューアイテムを追加

        Args:
            icon_path: アイコンファイルのパス
            text: アクションのテキスト
            callback: アクションが実行された時のコールバック関数
            enabled_flag: アクションが有効かどうか
            add_to_menu: メニューに追加するかどうか
            add_to_toolbar: ツールバーに追加するかどうか
            status_tip: ステータスバーに表示するヒント
            whats_this: What's Thisヘルプ
            parent: 親ウィジェット

        Returns:
            作成されたQActionオブジェクト
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # このプラグイン専用のツールバーに追加
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """プラグインのGUI要素を作成（プラグイン読み込み時に呼ばれる）"""
        icon_path = os.path.join(self.plugin_dir, 'icon.png')
        
        # パネル版のアクション
        if PANEL_AVAILABLE:
            self.add_action(
                icon_path,
                text=self.tr(u'QMap Permalink'),
                callback=self.toggle_panel,
                parent=self.iface.mainWindow())
        else:
            # パネルが利用できない場合は警告メッセージ
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available. Please try reinstalling the plugin."),
                level=2,  # WARNING
                duration=10
            )
            # Print diagnostic details to the Python Console so users/developers
            # can see the underlying import error (if available).
            try:
                if 'PANEL_IMPORT_ERROR' in globals() and PANEL_IMPORT_ERROR:
                    print(f"QMapPermalink: panel import error details:\n{PANEL_IMPORT_ERROR}")
            except Exception:
                pass

        # HTTPサーバーを起動
        self.server_manager.start_http_server()

        # 初回起動フラグ
        self.first_start = True

    def toggle_panel(self):
        """パネルの表示/非表示を切り替え"""
        if not PANEL_AVAILABLE:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available.")
            )
            return
            
        try:
            if self.panel is None:
                # パネル利用可能性をデバッグ
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    f"PANEL_AVAILABLE: {PANEL_AVAILABLE}, QMapPermalinkPanel: {QMapPermalinkPanel}", 
                    duration=5
                )
                
                # パネルを作成
                print("パネル作成開始...")
                self.panel = QMapPermalinkPanel(self.iface.mainWindow())
                print("パネル作成完了")
                
                # パネルのボタンにイベントを接続
                print("ボタンイベント接続開始...")
                self.panel.pushButton_generate.clicked.connect(self.on_generate_clicked_panel)
                self.panel.pushButton_navigate.clicked.connect(self.on_navigate_clicked_panel)
                self.panel.pushButton_copy.clicked.connect(self.on_copy_clicked_panel)
                if hasattr(self.panel, 'pushButton_open'):
                    self.panel.pushButton_open.clicked.connect(self.on_open_clicked_panel)
                
                # Google Maps/Earthボタンのイベントを接続
                if hasattr(self.panel, 'pushButton_google_maps'):
                    self.panel.pushButton_google_maps.clicked.connect(self.on_google_maps_clicked_panel)
                if hasattr(self.panel, 'pushButton_google_earth'):
                    self.panel.pushButton_google_earth.clicked.connect(self.on_google_earth_clicked_panel)
                
                # Check Access ボタンのイベントを接続
                if hasattr(self.panel, 'pushButton_check_access'):
                    self.panel.pushButton_check_access.clicked.connect(self.on_check_access_clicked)
                
                # 標準ポートボタンのイベントを接続
                if hasattr(self.panel, 'pushButton_port_80'):
                    self.panel.pushButton_port_80.clicked.connect(lambda: self.on_standard_port_clicked(80))
                if hasattr(self.panel, 'pushButton_port_443'):
                    self.panel.pushButton_port_443.clicked.connect(lambda: self.on_standard_port_clicked(443))
                
                print("ボタンイベント接続完了")
                
                # HTTPサーバーの状態を更新
                print("サーバー状態取得開始...")
                server_running = self.server_manager.is_server_running()
                server_port = self.server_manager.get_server_port() or 8089
                print(f"サーバー状態: running={server_running}, port={server_port}")
                print("パネル更新開始...")
                self.panel.update_server_status(server_port, server_running)
                
                # BBoxサーバーモードの初期化
                print(f"BBox manager available: {self.bbox_manager is not None}")
                
                try:
                    has_combo = hasattr(self.panel, 'comboBox_server_mode') and self.panel.comboBox_server_mode is not None
                    has_button = hasattr(self.panel, 'pushButton_download_bbox') and self.panel.pushButton_download_bbox is not None
                    print(f"Panel has comboBox_server_mode: {has_combo}")
                    print(f"Panel has pushButton_download_bbox: {has_button}")
                    
                    if self.bbox_manager and has_combo and has_button:
                        print("Initializing BBox server mode controls...")
                        
                        # バイナリの有無と起動状態を確認
                        has_binary = self.bbox_manager.get_binary_path() is not None
                        is_running = self.bbox_manager.is_running()
                        print(f"BBox binary exists: {has_binary}, path: {self.bbox_manager.get_binary_path()}")
                        print(f"BBox server running: {is_running}")
                        
                        # 初期状態を設定（UIのデフォルト値に基づく）
                        current_index = self.panel.comboBox_server_mode.currentIndex()
                        print(f"Initial comboBox index: {current_index}")
                        
                        if current_index == 0:  # Standard mode
                            self.panel.pushButton_download_bbox.setEnabled(False)
                            if is_running:
                                self.panel.pushButton_download_bbox.setText(self.tr("起動中"))
                            elif has_binary:
                                self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード済"))
                            else:
                                self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード"))
                        else:  # High-Speed mode
                            if is_running:
                                # 既に起動中
                                self.panel.pushButton_download_bbox.setEnabled(False)
                                self.panel.pushButton_download_bbox.setText(self.tr("起動中"))
                            elif has_binary:
                                # ダウンロード済みだが未起動
                                self.panel.pushButton_download_bbox.setEnabled(False)
                                self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード済"))
                            else:
                                # バイナリ未ダウンロード
                                self.panel.pushButton_download_bbox.setEnabled(True)
                                self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード"))
                        
                        print(f"Button enabled: {self.panel.pushButton_download_bbox.isEnabled()}")
                        print(f"Button text: {self.panel.pushButton_download_bbox.text()}")
                    else:
                        print("BBox controls not initialized (manager or UI missing)")
                except Exception as e:
                    print(f"Error initializing BBox controls: {e}")
                    import traceback
                    traceback.print_exc()
                
                # パネルのトグルチェックボックスをサーバー制御に接続
                try:
                    def _toggle_server(checked: bool):
                        try:
                            if checked:
                                # Get the port from spinBox if available
                                port = 8089
                                try:
                                    if hasattr(self.panel, 'spinBox_port') and self.panel.spinBox_port is not None:
                                        port = self.panel.spinBox_port.value()
                                except Exception:
                                    pass
                                self.server_manager.start_http_server(port)
                            else:
                                self.server_manager.stop_http_server()
                            # 更新後の状態をラベルに反映
                            pr = self.server_manager.get_server_port() or 8089
                            self.panel.update_server_status(pr, self.server_manager.is_server_running())
                        except Exception as e:
                            print(f"サーバートグルエラー: {e}")

                    # set_server_toggle_handler はパネル側で提供
                    if hasattr(self.panel, 'set_server_toggle_handler'):
                        self.panel.set_server_toggle_handler(_toggle_server)
                        # 初期状態を反映（checkbox自体は update_server_status で同期済み）
                except Exception:
                    pass
                # External control handler: when enabled, apply last received origin (if any)
                try:
                    def _external_control_toggled(checked: bool):
                        try:
                            if checked and self._last_request_origin:
                                # Navigate to the last origin when external control is turned on
                                self.navigate_to_permalink(self._last_request_origin)
                        except Exception as e:
                            print(f"External control handler error: {e}")

                    if hasattr(self.panel, 'set_external_control_handler'):
                        self.panel.set_external_control_handler(_external_control_toggled)
                except Exception:
                    pass
                
                # Port change handler: restart server with new port when changed
                try:
                    def _port_changed(new_port: int):
                        try:
                            # Only restart if server is currently running
                            if self.server_manager.is_server_running():
                                from qgis.PyQt.QtWidgets import QMessageBox
                                reply = QMessageBox.question(
                                    self.iface.mainWindow(),
                                    self.tr("QMap Permalink"),
                                    self.tr(f"サーバーを停止してポート {new_port} で再起動しますか？"),
                                    QMessageBox.Yes | QMessageBox.No,
                                    QMessageBox.No
                                )
                                if reply == QMessageBox.Yes:
                                    self.server_manager.stop_http_server()
                                    self.server_manager.start_http_server(new_port)
                        except Exception as e:
                            print(f"Port change error: {e}")
                    
                    if hasattr(self.panel, 'set_port_change_handler'):
                        self.panel.set_port_change_handler(_port_changed)
                except Exception:
                    pass
                
                # BBoxサーバーモード切り替えハンドラ
                try:
                    if self.bbox_manager and hasattr(self.panel, 'comboBox_server_mode') and self.panel.comboBox_server_mode is not None:
                        def _server_mode_changed(index: int):
                            try:
                                print(f"Server mode changed to index: {index}")
                                if index == 0:  # Standard (Python)
                                    if hasattr(self.panel, 'pushButton_download_bbox') and self.panel.pushButton_download_bbox is not None:
                                        self.panel.pushButton_download_bbox.setEnabled(False)
                                        print("Download button disabled (Standard mode)")
                                    # BBoxサーバーが動いていたら停止
                                    if self.bbox_manager and self.bbox_manager.is_running():
                                        self.bbox_manager.stop_server()
                                elif index == 1:  # High-Speed (Rust)
                                    if hasattr(self.panel, 'pushButton_download_bbox') and self.panel.pushButton_download_bbox is not None:
                                        # バイナリがあればボタン無効、なければ有効
                                        has_binary = self.bbox_manager.get_binary_path() is not None
                                        is_running = self.bbox_manager.is_running()
                                        print(f"Has binary: {has_binary}, Binary path: {self.bbox_manager.get_binary_path()}")
                                        print(f"BBox server running: {is_running}")
                                        
                                        # ボタンの状態とテキストを設定
                                        if is_running:
                                            # 既に起動中
                                            self.panel.pushButton_download_bbox.setEnabled(False)
                                            self.panel.pushButton_download_bbox.setText(self.tr("起動中"))
                                            self.iface.messageBar().pushMessage(
                                                self.tr("QMap Permalink"),
                                                self.tr("高速サーバーは既に起動しています (port 8080)"),
                                                duration=3
                                            )
                                        elif has_binary:
                                            # ダウンロード済みだが未起動
                                            self.panel.pushButton_download_bbox.setEnabled(False)
                                            self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード済"))
                                            # 起動を提案
                                            reply = QMessageBox.question(
                                                self.iface.mainWindow(),
                                                self.tr("QMap Permalink"),
                                                self.tr("高速サーバー(Rust)を起動しますか？\n標準サーバーは自動的に停止されます。"),
                                                QMessageBox.Yes | QMessageBox.No,
                                                QMessageBox.Yes
                                            )
                                            if reply == QMessageBox.Yes:
                                                # 標準サーバーを停止
                                                if self.server_manager.is_server_running():
                                                    self.server_manager.stop_http_server()
                                                # BBoxサーバーを起動
                                                success = self.bbox_manager.start_server(port=8080)
                                                if success:
                                                    self.panel.pushButton_download_bbox.setText(self.tr("起動中"))
                                                    self.iface.messageBar().pushMessage(
                                                        self.tr("QMap Permalink"),
                                                        self.tr("高速サーバーが起動しました (port 8080)"),
                                                        duration=3
                                                    )
                                        else:
                                            # バイナリ未ダウンロード
                                            self.panel.pushButton_download_bbox.setEnabled(True)
                                            self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード"))
                                            # ダウンロードを提案
                                            self.iface.messageBar().pushMessage(
                                                self.tr("QMap Permalink"),
                                                self.tr("高速サーバー(Rust)を使用するには、まずダウンロードボタンをクリックしてください"),
                                                duration=5
                                            )
                                        
                                        print(f"Download button enabled: {self.panel.pushButton_download_bbox.isEnabled()}")
                                        print(f"Download button text: {self.panel.pushButton_download_bbox.text()}")
                            except Exception as e:
                                print(f"Server mode change error: {e}")
                                import traceback
                                traceback.print_exc()
                        
                        self.panel.comboBox_server_mode.currentIndexChanged.connect(_server_mode_changed)
                        print("BBox server mode handler connected")
                except Exception as e:
                    print(f"Error connecting BBox server mode handler: {e}")
                    import traceback
                    traceback.print_exc()
                
                # BBoxダウンロードボタンハンドラ
                try:
                    if self.bbox_manager and hasattr(self.panel, 'pushButton_download_bbox') and self.panel.pushButton_download_bbox is not None:
                        print("Connecting BBox download button handler...")
                        def _download_bbox_clicked():
                            try:
                                print("Download button clicked!")
                                # ダウンロード開始
                                self.panel.pushButton_download_bbox.setEnabled(False)
                                self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード中..."))
                                print("Starting download...")
                                
                                def on_progress(percent):
                                    # シグナルはintのパーセンテージ値を受け取る
                                    print(f"Download progress: {percent}%")
                                    self.panel.pushButton_download_bbox.setText(f"{self.tr('ダウンロード中')} {percent}%")
                                
                                def on_complete():
                                    print("Download completed callback")
                                    self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード完了"))
                                    self.panel.pushButton_download_bbox.setEnabled(False)
                                    self.iface.messageBar().pushMessage(
                                        self.tr("QMap Permalink"),
                                        self.tr("高速サーバーのダウンロードが完了しました。"),
                                        duration=5
                                    )
                                    # ダウンロード完了後は起動を提案
                                    reply = QMessageBox.question(
                                        self.iface.mainWindow(),
                                        self.tr("QMap Permalink"),
                                        self.tr("高速サーバー(Rust)を起動しますか？\n標準サーバーは自動的に停止されます。"),
                                        QMessageBox.Yes | QMessageBox.No,
                                        QMessageBox.Yes
                                    )
                                    if reply == QMessageBox.Yes:
                                        print("Starting BBox server...")
                                        if self.server_manager.is_server_running():
                                            self.server_manager.stop_http_server()
                                        success = self.bbox_manager.start_server(port=8080)
                                        print(f"BBox server start result: {success}")
                                        if success:
                                            self.iface.messageBar().pushMessage(
                                                self.tr("QMap Permalink"),
                                                self.tr("高速サーバーが起動しました (port 8080)"),
                                                duration=3
                                            )
                                    else:
                                        # ボタンを再有効化 (バイナリは存在するので無効のまま)
                                        pass
                                
                                def on_error(error_msg):
                                    self.panel.pushButton_download_bbox.setText(self.tr("ダウンロード"))
                                    self.panel.pushButton_download_bbox.setEnabled(True)
                                    self.iface.messageBar().pushMessage(
                                        self.tr("QMap Permalink"),
                                        self.tr(f"ダウンロード失敗: {error_msg}"),
                                        duration=10
                                    )
                                
                                # 進捗コールバックを接続
                                self.bbox_manager.download_progress.connect(on_progress)
                                
                                # ダウンロードを実行（別スレッドで）
                                from qgis.PyQt.QtCore import QTimer
                                from qgis.core import QgsTask, QgsApplication
                                
                                class DownloadTask(QgsTask):
                                    def __init__(self, bbox_manager):
                                        super().__init__('BBOX Server Download', QgsTask.CanCancel)
                                        self.bbox_manager = bbox_manager
                                        self.success = False
                                        self.error = None
                                    
                                    def run(self):
                                        try:
                                            print("DownloadTask.run() started")
                                            self.success = self.bbox_manager.download_server()
                                            print(f"DownloadTask.run() finished: {self.success}")
                                            return self.success
                                        except Exception as e:
                                            print(f"DownloadTask.run() error: {e}")
                                            import traceback
                                            traceback.print_exc()
                                            self.error = str(e)
                                            return False
                                    
                                    def finished(self, result):
                                        print(f"DownloadTask.finished() called: result={result}")
                                        if result:
                                            on_complete()
                                        else:
                                            on_error(self.error or "Unknown error")
                                
                                task = DownloadTask(self.bbox_manager)
                                QgsApplication.taskManager().addTask(task)
                                
                            except Exception as e:
                                print(f"Download button error: {e}")
                                import traceback
                                traceback.print_exc()
                        
                        self.panel.pushButton_download_bbox.clicked.connect(_download_bbox_clicked)
                        print("BBox download button handler connected")
                except Exception as e:
                    print(f"Error connecting BBox download button handler: {e}")
                    import traceback
                    traceback.print_exc()

                # If external control is already checked at panel creation, apply last origin
                try:
                    if getattr(self.panel, 'checkBox_external_control', None) is not None and self.panel.checkBox_external_control.isChecked():
                        if self._last_request_origin:
                            try:
                                self.navigate_to_permalink(self._last_request_origin)
                            except Exception:
                                pass
                except Exception:
                    pass
                print("パネル更新完了")
                
                # テーマ一覧を更新
                self.update_theme_list()
                
                # QGISのメインウィンドウの左側にドッキング
                self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.panel)
                
                # 既存の左側パネルがあればタブ化
                self._try_tabify_with_existing_panels()
                
                # デバッグメッセージ
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Panel created successfully."), 
                    duration=3
                )
            else:
                # パネルの表示/非表示を切り替え
                if self.panel.isVisible():
                    self.panel.hide()
                else:
                    self.panel.show()
                    
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"パネル作成エラーの詳細:\n{error_details}")
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to create panel: {error}").format(error=str(e))
            )

    def on_open_clicked_panel(self):
        """パネルの 'Open' ボタンが押されたときに /web-ui/ を開く"""
        try:
            port = self.server_manager.get_server_port() or 8089
            url = QUrl(f'http://localhost:{port}/web-ui/')
            if not QDesktopServices.openUrl(url):
                QMessageBox.warning(self.iface.mainWindow(), self.tr('QMap Permalink'), self.tr('Failed to open web UI in browser.'))
        except Exception as e:
            QMessageBox.warning(self.iface.mainWindow(), self.tr('QMap Permalink'), self.tr(f'Error opening web UI: {e}'))

    def _try_tabify_with_existing_panels(self):
        """既存の左側パネルがあればタブ化を試行"""
        try:
            # QGISメインウィンドウから左側ドックエリアのウィジェットを取得
            main_window = self.iface.mainWindow()
            
            # よく使われるパネル名のリスト（優先順位順）
            preferred_panels = [
                'Layers',           # レイヤーパネル
                'Browser',          # ブラウザパネル
                'Browser2',         # ブラウザパネル（別名）
                'LayerOrder',       # レイヤー順序パネル
                'Processing',       # プロセシングツールボックス
                'History',          # 履歴パネル
            ]
            
            target_panel = None
            
            # 優先パネルから検索
            for panel_name in preferred_panels:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible() and
                        (panel_name.lower() in widget.objectName().lower() or
                         panel_name.lower() in widget.windowTitle().lower())):
                        target_panel = widget
                        break
                if target_panel:
                    break
            
            # 優先パネルが見つからない場合は左側の最初のパネルを使用
            if not target_panel:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible()):
                        target_panel = widget
                        break
            
            # タブ化実行
            if target_panel:
                main_window.tabifyDockWidget(target_panel, self.panel)
                
                # QMapPermalinkパネルをアクティブにする
                self.panel.raise_()
                
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Tabified with '{panel_name}' panel.").format(panel_name=target_panel.windowTitle()), 
                    duration=3
                )
            else:
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Displayed as an independent panel on the left side."), 
                    duration=3
                )
                
        except Exception as e:
            # タブ化に失敗しても継続
            print(f"パネルのタブ化でエラー: {e}")
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                self.tr("Panel displayed on the left side."), 
                duration=3
            )

    def unload(self):
        """プラグインのアンロード時の処理"""
        # HTTPサーバーを停止
        self.server_manager.stop_http_server()
        
        # BBoxサーバーを停止
        if self.bbox_manager and self.bbox_manager.is_running():
            self.bbox_manager.stop_server()
        
        # パネルを削除
        if self.panel is not None:
            self.iface.removeDockWidget(self.panel)
            self.panel = None
        
        # シグナルを切断
        if hasattr(self, 'navigation_signals'):
            self.navigation_signals.navigate_requested.disconnect()
        
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QMap Permalink'),
                action)
            self.iface.removeToolBarIcon(action)






        
    # 純粋にHTTPサーバー関連のメソッドは qmap_permalink_server_manager.py に移動しました
    # _build_google_maps_url, _build_google_earth_url, _estimate_zoom_from_scale, _convert_to_wgs84 は
    # メインファイルでも使用されるため、こちらに残しています



    def _build_google_maps_url(self, navigation_data):
        """ナビゲーションデータからGoogle Maps用URLを生成

        Google Maps用は zoom が必要。zoom が与えられなければ scale から推定する。
        最終フォールバックは zoom=16 とする。
        """
        try:
            if navigation_data.get('type') == 'coordinates':
                lat, lon = self._resolve_coordinates(navigation_data)
                if lat is None or lon is None:
                    return None
                # zoom が無ければ scale から推定し、無ければデフォルト16を使う
                zoom_value = navigation_data.get('zoom')
                if zoom_value is None:
                    zoom_value = self._estimate_zoom_from_scale(navigation_data.get('scale'))
                if zoom_value is None:
                    zoom_value = 16.0
                # 小数点レベルのズームをサポート（最大2桁まで）
                zoom_formatted = f"{float(zoom_value):.2f}".rstrip('0').rstrip('.')
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_formatted}z"

            if navigation_data.get('type') == 'location':
                lat = navigation_data.get('lat')
                lon = navigation_data.get('lon')
                zoom_value = navigation_data.get('zoom')

                if lat is None or lon is None:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                    except Exception:
                        data = {}

                    if data:
                        center_lat = data.get('center_wgs84_lat')
                        center_lon = data.get('center_wgs84_lon')
                        if center_lat is not None and center_lon is not None:
                            lat = float(center_lat)
                            lon = float(center_lon)
                        else:
                            center_x = data.get('center_x')
                            center_y = data.get('center_y')
                            crs_authid = data.get('center_crs') or data.get('crs')
                            if center_x is not None and center_y is not None and crs_authid:
                                lat, lon = self._convert_to_wgs84(center_x, center_y, crs_authid)
                        if zoom_value is None:
                            zoom_value = self._estimate_zoom_from_scale(data.get('scale'))

                if (lat is None or lon is None) and navigation_data.get('center_x') is not None:
                    crs_authid = navigation_data.get('crs')
                    lat, lon = self._convert_to_wgs84(
                        navigation_data.get('center_x'),
                        navigation_data.get('center_y'),
                        crs_authid,
                    )

                if lat is None or lon is None:
                    return None

                if zoom_value is None:
                    zoom_value = 16.0

                # 小数点レベルのズームをサポート（最大2桁まで）
                zoom_formatted = f"{float(zoom_value):.2f}".rstrip('0').rstrip('.')
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_formatted}z"

        except Exception:
            return None

        return None

    def _build_google_earth_url(self, navigation_data):
        """ナビゲーションデータからGoogle Earth用URLを生成

        Google Earth Web版用のURL形式: https://earth.google.com/web/@lat,lon,altitude,heading,tilt,roll
        Google Mapsと同じスケール変換を使用してより正確な高度を計算します。
        """
        try:
            if navigation_data.get('type') == 'coordinates':
                lat, lon = self._resolve_coordinates(navigation_data)
                if lat is None or lon is None:
                    return None
                
                # Google Mapsと同じズームレベル推定を使用
                zoom_value = navigation_data.get('zoom')
                if zoom_value is None:
                    zoom_value = self._estimate_zoom_from_scale(navigation_data.get('scale'))
                if zoom_value is None:
                    zoom_value = 16.0
                
                # Google Earth用の正確なパラメータ計算（実測値に基づく）
                # 実測分析: 1:15695スケール → 距離5554m、高度22m
                if navigation_data.get('scale'):
                    scale_value = navigation_data['scale']
                else:
                    # ズームレベルからスケールを逆算
                    estimated_scale = self._estimate_scale_from_zoom(zoom_value)
                    scale_value = estimated_scale
                
                # 実測データに基づくGoogle Earth用パラメータ計算
                # 実測値: 1:15695スケール → 高度32m、距離160699m、1y角度
                if scale_value:
                    # 実測基準値
                    reference_scale = 15695.0
                    reference_altitude = 32.03670052  # 実測高度
                    reference_distance = 160699.35527964  # 実測距離
                    
                    # スケールに比例した高度計算（実測データベース）
                    altitude = reference_altitude * (scale_value / reference_scale) ** 0.5
                    altitude = max(10.0, min(2000.0, altitude))
                    
                    # スケールに比例した距離計算（実測データベース）
                    distance = reference_distance * (scale_value / reference_scale)
                    distance = max(100.0, min(500000.0, distance))
                else:
                    altitude = 100.0
                    distance = 50000.0
                
                # 実測に基づくGoogle Earth URL形式（1y角度で適切な表示）
                return f"https://earth.google.com/web/@{lat:.6f},{lon:.6f},{altitude:.8f}a,{distance:.8f}d,1y,0h,0t,0r"

            if navigation_data.get('type') == 'location':
                lat = navigation_data.get('lat')
                lon = navigation_data.get('lon')
                zoom_value = navigation_data.get('zoom')

                if lat is None or lon is None:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                    except Exception:
                        data = {}

                    if data:
                        center_lat = data.get('center_wgs84_lat')
                        center_lon = data.get('center_wgs84_lon')
                        if center_lat is not None and center_lon is not None:
                            lat = float(center_lat)
                            lon = float(center_lon)
                        else:
                            center_x = data.get('center_x')
                            center_y = data.get('center_y')
                            crs_authid = data.get('center_crs') or data.get('crs')
                            if center_x is not None and center_y is not None and crs_authid:
                                lat, lon = self._convert_to_wgs84(center_x, center_y, crs_authid)
                        if zoom_value is None:
                            zoom_value = self._estimate_zoom_from_scale(data.get('scale'))

                if (lat is None or lon is None) and navigation_data.get('center_x') is not None:
                    crs_authid = navigation_data.get('crs')
                    lat, lon = self._convert_to_wgs84(
                        navigation_data.get('center_x'),
                        navigation_data.get('center_y'),
                        crs_authid,
                    )

                if lat is None or lon is None:
                    return None

                if zoom_value is None:
                    zoom_value = 16.0

                # Google Earth用の正確なパラメータ計算（実測值に基づく）
                scale_value = navigation_data.get('scale')
                if not scale_value and 'location' in navigation_data:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                        scale_value = data.get('scale')
                    except Exception:
                        pass
                
                if scale_value:
                    # 実測データに基づくGoogle Earth用パラメータ計算
                    # 実測値: 1:15695スケール → 高度32m、距離160699m、1y角度
                    reference_scale = 15695.0
                    reference_altitude = 32.03670052  # 実測高度
                    reference_distance = 160699.35527964  # 実測距離
                    
                    # スケールに比例した高度計算（実測データベース）
                    altitude = reference_altitude * (scale_value / reference_scale) ** 0.5
                    altitude = max(10.0, min(2000.0, altitude))
                    
                    # スケールに比例した距離計算（実測データベース）
                    distance = reference_distance * (scale_value / reference_scale)
                    distance = max(100.0, min(500000.0, distance))
                else:
                    altitude = 100.0
                    distance = 50000.0
                
                # 実測に基づくGoogle Earth URL形式（1y角度で適切な表示）
                return f"https://earth.google.com/web/@{lat:.6f},{lon:.6f},{altitude:.8f}a,{distance:.8f}d,1y,0h,0t,0r"

        except Exception:
            return None

        return None

    def _resolve_coordinates(self, navigation_data):
        """ナビゲーションデータからWGS84座標を求める"""
        lat = navigation_data.get('lat')
        lon = navigation_data.get('lon')
        if lat is not None and lon is not None:
            return float(lat), float(lon)

        x = navigation_data.get('x')
        y = navigation_data.get('y')
        crs_authid = navigation_data.get('crs')
        if x is None or y is None or crs_authid is None:
            return None, None

        return self._convert_to_wgs84(x, y, crs_authid)


    def _estimate_zoom_from_scale(self, scale):
        """スケール値からGoogle Maps用ズームレベルを推定（連続値対応改良版）
        
        固定テーブル方式をベースに、テーブル間の中間値を線形補間で計算し、
        小数点レベルでの詳細なズームレベル推定を可能にします。
        """
        # Delegate to the pure-Python utility to avoid duplicating logic.
        try:
            from .scale_zoom import estimate_zoom_from_scale
            return float(estimate_zoom_from_scale(scale))
        except Exception:
            # Fallback default if for some reason the utility cannot be used
            try:
                if not scale:
                    return 16.0
            except Exception:
                pass
            return 16.0

    def _zoom_to_earth_distance(self, zoom_level):
        """ズームレベルからGoogle Earth用の適切な距離を計算
        
        Args:
            zoom_level: ズームレベル（小数点可）
            
        Returns:
            距離（メートル）
        """
        if zoom_level is None:
            return 5000
            
        try:
            z = float(zoom_level)
            # ズームレベルに対応する距離テーブル
            zoom_distances = {
                0: 20000000, 1: 10000000, 2: 5000000, 3: 2000000, 4: 1000000,
                5: 500000, 6: 200000, 7: 100000, 8: 50000, 9: 20000,
                10: 10000, 11: 5000, 12: 2000, 13: 1000, 14: 500,
                15: 200, 16: 100, 17: 50, 18: 20, 19: 10, 20: 5
            }
            
            # 最も近い整数ズームレベルの距離を使用
            rounded_zoom = max(0, min(20, round(z)))
            return zoom_distances.get(rounded_zoom, 5000)
            
        except (ValueError, TypeError):
            return 5000

    def _parse_google_maps_at_url(self, url):
        """Google Maps の @lat,lon,XXXm または @lat,lon,ZZz 形式を解析する

        戻り値: {'lat': float, 'lon': float, 'zoom': float or None, 'scale': float or None}
        解析できなければ None を返す。
        """
        try:
            parsed = urllib.parse.urlparse(url)
            path = parsed.path or ''

            # Quick direct match: @lat,lon,NNNm (common simple form). This handles
            # cases like '/@35.6778996,139.6960404,883m/' quickly without token-splitting.
            try:
                m_quick = re.search(r'@([-0-9.]+),([-0-9.]+),([0-9.]+)m(?=[/,%s]|$)' % (r'\s'), url)
                if m_quick:
                    lat = float(m_quick.group(1))
                    lon = float(m_quick.group(2))
                    map_width_m = float(m_quick.group(3))
                    return {'lat': lat, 'lon': lon, 'zoom': None, 'scale': None, 'map_width_m': map_width_m}
            except Exception:
                # ignore and continue with the more flexible parser below
                pass

            # パス中の @lat,lon[,rest] を探す（rest は省略可能）
            m = re.search(r'@([-0-9.]+),([-0-9.]+)(?:,([^/\s]+))?', path)
            if not m:
                # 一部の Google URL はパスではなく完全URLに @ を含むことがある
                # その場合は raw URL 全体を検索する
                m = re.search(r'@([-0-9.]+),([-0-9.]+)(?:,([^/\s]+))?', url)
            if not m:
                return None

            lat = float(m.group(1))
            lon = float(m.group(2))
            rest = m.group(3) if m.lastindex and m.lastindex >= 3 else None

            zoom = None
            scale = None
            map_width_m = None

            # rest の例: '220m', '16z', '16.00z', '15.5z', '220m,15z' など
            # 複数トークンがある場合は順序に依存せず 'm' と 'z' を探索する
            if rest:
                # split by comma and inspect each token
                tokens = [t.strip() for t in rest.split(',') if t.strip()]
                for tok in tokens:
                    m2 = re.match(r'^([0-9.]+)(m|z)?', tok, re.IGNORECASE)
                    if not m2:
                        continue
                    try:
                        val = float(m2.group(1))
                    except Exception:
                        continue
                    suf = (m2.group(2) or '').lower()

                    # if suffix is 'z' or absent, treat as zoom
                    if suf == 'z' or suf == '':
                        # prefer first zoom seen
                        if zoom is None:
                            try:
                                zoom = float(val)
                                try:
                                    scale = self._estimate_scale_from_zoom(zoom)
                                except Exception:
                                    scale = None
                            except Exception:
                                zoom = None
                    elif suf == 'm':
                        # prefer first map_width_m seen
                        if map_width_m is None:
                            try:
                                map_width_m = float(val)
                            except Exception:
                                map_width_m = None

            result = {'lat': lat, 'lon': lon, 'zoom': zoom, 'scale': scale}
            # attach map_width_m if set
            try:
                if 'map_width_m' in locals() and map_width_m is not None:
                    result['map_width_m'] = map_width_m
            except Exception:
                pass
            return result
        except Exception:
            return None

    def _parse_google_earth_url(self, url):
        """Google Earth Web の @lat,lon,altitudea,distanced,... 形式を解析する

        戻り値: {'lat': float, 'lon': float, 'zoom': float, 'scale': float, 'altitude': float, 'distance': float}
        解析できなければ None を返す。
        """
        try:
            # 例: https://earth.google.com/web/@35.80234294,139.52998754,48.51663142a,501601.82953767d,1y,...
            # Capture optional 'y' token which Google Earth uses (e.g. '1y')
            # Format examples:
            #  - @lat,lon,altitudea,distanced,1y,...
            #  - @lat,lon,altitudea,distanced,...
            m = re.search(r'@([-0-9.]+),([-0-9.]+),([0-9.]+(?:\.[0-9]+)?)a,([0-9.]+(?:\.[0-9]+)?)d(?:,([0-9.]+(?:\.[0-9]+)?)y)?', url)
            if not m:
                return None

            lat = float(m.group(1))
            lon = float(m.group(2))
            altitude = float(m.group(3))
            distance = float(m.group(4))

            y_token = None
            try:
                if m.lastindex and m.lastindex >= 5 and m.group(5):
                    y_token = float(m.group(5))
            except Exception:
                y_token = None

            zoom_est = None
            scale_est = None
            try:
                # If an explicit distance token is present, invert the same model
                # used in _build_google_earth_url. That builder uses a sqrt scaling
                # (distance = reference_distance * sqrt(scale / reference_scale)),
                # so the algebraic inverse is: scale = reference_scale * (distance / reference_distance) ** 2
                if distance is not None and float(distance) > 0:
                    try:
                        d = float(distance)
                        reference_scale = 15695.0
                        reference_distance = 160699.35527964
                        if reference_distance != 0:
                            scale_est = float(reference_scale * (d / reference_distance) ** 2)
                        else:
                            scale_est = None
                        if scale_est and scale_est > 0:
                            zoom_est = float(self._estimate_zoom_from_scale(scale_est))
                        else:
                            zoom_est = None
                    except Exception:
                        scale_est = None
                        zoom_est = None
                elif y_token and y_token > 0:
                    # Defensive fallback: interpret y_token as meters-per-pixel (m/px)
                    try:
                        dpi = float(self._get_screen_dpi())
                    except Exception:
                        dpi = 96.0
                    scale_candidate = float(y_token) * float(dpi) / 0.0254
                    if scale_candidate > 50.0 and scale_candidate < 100000000.0:
                        scale_est = float(scale_candidate)
                        zoom_est = float(self._estimate_zoom_from_scale(scale_est))
                    else:
                        scale_est = None
                        zoom_est = None
                else:
                    zoom_est = None
                    scale_est = None
            except Exception:
                zoom_est = None
                scale_est = None

            return {'lat': lat, 'lon': lon, 'zoom': zoom_est, 'scale': scale_est, 'altitude': altitude, 'distance': distance}
        except Exception:
            return None

    def _extract_altitude_from_earth_url(self, url):
        """Google Earth Web の URL から altitude（高度, メートル）を抽出するヘルパー。

        Google Earth の URL では高度と距離が `...,{altitude}a,{distance}d,...` のように表現されることが多いです。
        この関数は altitude 部分を見つけて float で返します。

        Args:
            url (str): Google Earth の @... 形式を含む URL

        Returns:
            float: altitude（メートル）

        Raises:
            ValueError: 高度が見つからない場合
        """
        try:
            # よくある形式: @lat,lon,altitudea,distanced,...
            m = re.search(r'@[-0-9.]+,[-0-9.]+,(-?[0-9.]+)a,([0-9.]+)d', url)
            if not m:
                # 別の形式やマイナスゼロなども考慮して柔軟に検索
                m2 = re.search(r',(-?[0-9.]+)a,([0-9.]+)d', url)
                if not m2:
                    raise ValueError("Altitude not found in URL")
                return float(m2.group(1))
            return float(m.group(1))
        except Exception as e:
            raise ValueError(f"Altitude extraction failed: {e}")

    def _estimate_ground_resolution_from_altitude(self, altitude_meters, latitude_deg, pixel_angle_deg=0.00028):
        """与えられた高度（m）と中心緯度（度）から概算の地上解像度（メートル/ピクセル）を計算する。

        注記: この計算はおおよその概算であり、実際の表示スケールはモニタ解像度、表示領域のピクセル数、投影
        の影響などに依存します。ここでは単純化した幾何学モデルを用いて m/px の見積もりを返します。

        Args:
            altitude_meters (float): カメラ/観測点の高度（メートル）
            latitude_deg (float): 地表の中心緯度（度）
            pixel_angle_deg (float): 画面上1ピクセルが占める角度（度）。デフォルトは 0.00028deg（概算）

        Returns:
            float: 推定される地上解像度（メートル/ピクセル）
        """
        try:
            earth_radius = 6371000.0
            r = float(earth_radius) + float(altitude_meters)
            pixel_angle_rad = math.radians(float(pixel_angle_deg))
            lat_correction = math.cos(math.radians(float(latitude_deg)))
            ground_resolution = r * pixel_angle_rad * lat_correction
            return float(ground_resolution)
        except Exception:
            return None

    def _estimate_scale_from_zoom(self, zoom_level):
        """ズームレベルからスケール値を逆算（小数点対応版）
        
        小数点レベルのズームレベルにも対応し、線形補間でスケール値を計算します。
        
        Args:
            zoom_level: ズームレベル（小数点可）
            
        Returns:
            推定スケール値
        """
        try:
            from .scale_zoom import estimate_scale_from_zoom
            return float(estimate_scale_from_zoom(zoom_level))
        except Exception:
            return 20000.0

    def _convert_to_wgs84(self, x, y, source_crs_authid):
        """任意座標をWGS84へ変換"""
        try:
            source_crs = QgsCoordinateReferenceSystem(str(source_crs_authid))
            if not source_crs.isValid():
                return None, None
            target_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            point = transform.transform(QgsPointXY(float(x), float(y)))
            return float(point.y()), float(point.x())
        except Exception:
            return None, None

    def _convert_wgs84_to_crs(self, lat, lon, target_crs_authid):
        """WGS84 座標 (lat, lon) を target CRS の座標に変換して返す (x, y) 形式

        Returns (x, y) or (None, None) on error.
        """
        try:
            source_crs = QgsCoordinateReferenceSystem('EPSG:4326')
            target_crs = QgsCoordinateReferenceSystem(str(target_crs_authid))
            if not target_crs.isValid():
                return None, None
            transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            pt = transform.transform(QgsPointXY(float(lon), float(lat)))
            return float(pt.x()), float(pt.y())
        except Exception:
            return None, None

    def _compute_scale_from_map_width(self, center_lat, map_width_m, target_crs_authid=None):
        """地球上の map_width_m (表示横幅メートル) を QGIS の scale に換算する簡易計算

        アプローチ:
        - WGS84 の中心緯度から経度方向の地球上の長さ（1度あたりのメートル）を計算
        - 表示横幅 map_width_m を度に変換し、目的座標系での地図単位とピクセル幅からスケールを推定
        - ここでは簡易的に: scale = (map_width_map_units) / (map_units_per_pixel) を目標とするが、
          map_units_per_pixel は実行時のキャンバスから取得する必要があるため、呼び出し側で最終換算を行う。

        Returns estimated_scale_meters_per_map_unit (approx) or None.
        """
        try:
            # Earth radius approximation
            R = 6378137.0
            # length of one degree longitude at given latitude
            lat_rad = math.radians(float(center_lat))
            meters_per_deg_lon = (math.pi / 180.0) * R * math.cos(lat_rad)
            # map_width_m divided by meters_per_deg_lon -> degrees of longitude
            deg_width = float(map_width_m) / meters_per_deg_lon if meters_per_deg_lon != 0 else None
            return {'deg_width': deg_width, 'meters_per_deg_lon': meters_per_deg_lon}
        except Exception:
            return None

    def _compute_scale_from_map_width_with_dpi(self, center_lat, map_width_m, canvas, dpi=96):
        """Compute map scale denominator (approx) from desired map width in meters, using canvas size and DPI.

        Returns scale_denominator (e.g. 10000 for 1:10000) or None.
        """
        try:
            dest_crs = canvas.mapSettings().destinationCrs()
            # compute deg width and meters per degree at center
            info = self._compute_scale_from_map_width(center_lat, map_width_m, dest_crs.authid())
            if not info or not info.get('deg_width'):
                return None
            deg_width = info['deg_width']
            # convert deg left/right to destination CRS map units
            try:
                # get canvas center in dest CRS and transform to WGS84
                center_map = canvas.extent().center()
                wgs_lat, wgs_lon = self._convert_to_wgs84(center_map.x(), center_map.y(), dest_crs.authid())
                if wgs_lat is None or wgs_lon is None:
                    return None
            except Exception:
                return None

            lon_center = wgs_lon
            lon_left = lon_center - deg_width / 2.0
            lon_right = lon_center + deg_width / 2.0
            x_left, y_left = self._convert_wgs84_to_crs(wgs_lat, lon_left, dest_crs.authid())
            x_right, y_right = self._convert_wgs84_to_crs(wgs_lat, lon_right, dest_crs.authid())
            if x_left is None or x_right is None:
                return None
            map_width_map_units = abs(x_right - x_left)

            canvas_width_px = canvas.size().width()
            if canvas_width_px <= 0:
                return None

            desired_map_units_per_pixel = map_width_map_units / float(canvas_width_px)

            # Preferred method: use current canvas.mapUnitsPerPixel() and canvas.scale() to compute new scale
            try:
                current_map_units_per_pixel = canvas.mapUnitsPerPixel()
                current_scale = canvas.scale()
                if current_map_units_per_pixel and current_scale:
                    # scale is proportional to mapUnitsPerPixel, so we can scale by the ratio
                    scale_denominator = float(current_scale) * (desired_map_units_per_pixel / float(current_map_units_per_pixel))
                    if scale_denominator > 0:
                        return float(scale_denominator)
            except Exception:
                # Fall back to DPI-based conversion below
                pass

            # Fallback: Convert meters per pixel to scale denominator using DPI
            meters_per_pixel = map_width_map_units / float(canvas_width_px)
            scale_denominator = meters_per_pixel * float(dpi) / 0.0254
            if scale_denominator <= 0:
                return None
            return float(scale_denominator)
        except Exception:
            return None


    def _get_screen_dpi(self):
        """Attempt to obtain the current screen DPI via Qt (logical or physical DPI).

        Returns a float DPI value. Falls back to 96.0 if no reliable value can be obtained.
        """
        try:
            # Prefer the QApplication primary screen if available
            app = QApplication.instance()
            screen = None
            if app:
                try:
                    screen = app.primaryScreen()
                except Exception:
                    screen = None

            # Fallback: try to get the main window's screen
            if not screen:
                try:
                    mw = getattr(self, 'iface', None) and self.iface.mainWindow()
                    if mw:
                        screen = mw.screen()
                except Exception:
                    screen = None

            if screen:
                # Prefer logical DPI (accounts for OS scaling). Try several getters defensively.
                try:
                    dpi = screen.logicalDotsPerInch()
                    if dpi and dpi > 0:
                        return float(dpi)
                except Exception:
                    pass
                try:
                    dpi = screen.logicalDotsPerInchX()
                    if dpi and dpi > 0:
                        return float(dpi)
                except Exception:
                    pass
                try:
                    dpi = screen.physicalDotsPerInch()
                    if dpi and dpi > 0:
                        return float(dpi)
                except Exception:
                    pass
        except Exception:
            pass
        # final fallback
        return 96.0


    def _set_extent_for_map_width(self, center_lat, center_lon, map_width_m, canvas):
        """Set the canvas extent so that the horizontal map width (in meters) is approximately map_width_m.

        Approach:
        - Compute degree longitude width at center latitude from map_width_m.
        - Convert left/right WGS84 points to destination CRS (map units) and compute map width in map units.
        - Use canvas aspect ratio to compute map height in map units.
        - Build QgsRectangle around center in destination CRS and setExtent.

        Returns True on success, False on failure.
        """
        try:
            # destination CRS of canvas
            dest_crs = canvas.mapSettings().destinationCrs()

            # meters per degree longitude at latitude
            R = 6378137.0
            lat_rad = math.radians(float(center_lat))
            meters_per_deg_lon = (math.pi / 180.0) * R * math.cos(lat_rad)
            if meters_per_deg_lon == 0:
                return False

            deg_width = float(map_width_m) / meters_per_deg_lon

            lon_left = float(center_lon) - deg_width / 2.0
            lon_right = float(center_lon) + deg_width / 2.0

            # convert center and left/right to destination CRS
            cx, cy = self._convert_wgs84_to_crs(float(center_lat), float(center_lon), dest_crs.authid())
            lx, ly = self._convert_wgs84_to_crs(float(center_lat), lon_left, dest_crs.authid())
            rx, ry = self._convert_wgs84_to_crs(float(center_lat), lon_right, dest_crs.authid())
            if cx is None or lx is None or rx is None:
                return False

            map_width_map_units = abs(rx - lx)
            # Diagnostic logging
            try:
                print(f"_set_extent_for_map_width diagnostics: center=({center_lat},{center_lon}), deg_width={deg_width}, meters_per_deg_lon={meters_per_deg_lon}, x_left={lx}, x_right={rx}, map_width_map_units={map_width_map_units}")
                try:
                    self.iface.messageBar().pushMessage("QMap Permalink", f"set_extent diagnostics: map_width_map_units={map_width_map_units}, cw={cw}, ch={ch}", duration=6)
                except Exception:
                    pass
            except Exception:
                pass
            if map_width_map_units <= 0:
                return False

            # use canvas aspect ratio to compute map height in map units
            cw = float(canvas.size().width())
            ch = float(canvas.size().height())
            if cw <= 0 or ch <= 0:
                return False
            aspect = ch / cw
            map_height_map_units = map_width_map_units * aspect

            half_w = map_width_map_units / 2.0
            half_h = map_height_map_units / 2.0

            extent = QgsRectangle(cx - half_w, cy - half_h, cx + half_w, cy + half_h)

            canvas.setDestinationCrs(dest_crs)
            canvas.setExtent(extent)
            canvas.refresh()
            return True
        except Exception:
            return False

    def _compute_scale_from_map_width_at_center(self, center_lat, center_lon, map_width_m, canvas):
        """Estimate a scale denominator by computing target map units width around center and
        using current canvas.mapUnitsPerPixel() or fallback to meters-per-pixel + DPI method.

        Returns scale_denominator (float) or None.
        """
        try:
            dest_crs = canvas.mapSettings().destinationCrs()
            # meters per degree lon at latitude
            R = 6378137.0
            lat_rad = math.radians(float(center_lat))
            meters_per_deg_lon = (math.pi / 180.0) * R * math.cos(lat_rad)
            if meters_per_deg_lon == 0:
                return None

            deg_width = float(map_width_m) / meters_per_deg_lon

            lon_left = float(center_lon) - deg_width / 2.0
            lon_right = float(center_lon) + deg_width / 2.0

            x_left, y_left = self._convert_wgs84_to_crs(float(center_lat), lon_left, dest_crs.authid())
            x_right, y_right = self._convert_wgs84_to_crs(float(center_lat), lon_right, dest_crs.authid())
            if x_left is None or x_right is None:
                return None

            map_width_map_units = abs(x_right - x_left)

            # prefer to use current mapUnitsPerPixel and current scale
            try:
                current_map_units_per_pixel = canvas.mapUnitsPerPixel()
                current_scale = canvas.scale()
                if current_map_units_per_pixel and current_scale:
                    target_map_units_per_pixel = map_width_map_units / float(canvas.size().width())
                    scale_denominator = float(current_scale) * (target_map_units_per_pixel / float(current_map_units_per_pixel))
                    if scale_denominator > 0:
                        return float(scale_denominator)
            except Exception:
                pass

            # fallback to DPI method
            try:
                dpi = float(self._get_screen_dpi())
            except Exception:
                dpi = 96.0
            meters_per_pixel = map_width_map_units / float(canvas.size().width())
            scale_denominator = meters_per_pixel * dpi / 0.0254
            if scale_denominator > 0:
                return float(scale_denominator)
            return None
        except Exception:
            return None


    
    def generate_permalink(self, include_theme=True, specific_theme=None):
        """現在の地図ビューからパーマリンクを生成
        
        Args:
            include_theme (bool): テーマ情報を含めるかどうか
            specific_theme (str): 指定するテーマ名（None の場合は現在の状態を使用）
        
        Returns:
            パーマリンクURL文字列（HTTP形式）
        """
        # 現在のマップキャンバス情報を取得
        canvas = self.iface.mapCanvas()
        extent = canvas.extent()
        crs = canvas.mapSettings().destinationCrs()
        scale = canvas.scale()
        # 回転角度（度）
        rotation = canvas.rotation() if hasattr(canvas, 'rotation') else 0.0
        map_units_per_pixel = canvas.mapUnitsPerPixel()
        center_point = QgsPointXY(
            (extent.xMinimum() + extent.xMaximum()) / 2.0,
            (extent.yMinimum() + extent.yMaximum()) / 2.0,
        )

        # スケールからズームレベルを推定（Web標準対応でより正確）
        zoom_level = self._estimate_zoom_from_scale(scale)

        # 基本パラメータを構築
        x_val = f"{center_point.x():.6f}"
        y_val = f"{center_point.y():.6f}"
        crs_id = crs.authid()  # e.g. 'EPSG:3857' or 'EPSG:4326'
        # scale はキャンバスの scale() を使う
        scale_val = float(scale) if scale is not None else None
        if scale_val is None:
            # 万が一 scale が取得できなければ、ズームレベルから推定して scale を算出（逆算は簡易）
            # ここでは推定値として 1000 を入れておく
            scale_val = 1000.0
        
        # 基本URL構築（OpenLayersページ生成用）
        server_port = self.server_manager.get_server_port() or 8089
        
        permalink_url = (
            f"http://localhost:{server_port}/qgis-map?x={x_val}&y={y_val}"
            f"&scale={scale_val:.1f}&crs={crs_id}&rotation={rotation:.2f}"
        )
        
        # テーマ情報を追加（オプション）
        if include_theme and specific_theme:
            # シンプルなテーマ名をパラメータに追加
            theme_encoded = urllib.parse.quote(specific_theme)
            permalink_url += f"&theme={theme_encoded}"

        # MapLibre 用のスタイルはクライアント側で個別に取得・注入するため、
        # パーマリンクに typename を付与する処理は行わない（削除）。
        
        return permalink_url

    def navigate_to_permalink(self, permalink_url):
        """パーマリンクURLから地図ビューに移動
        
        Args:
            permalink_url: パーマリンクURL
        """
        try:
            # Normalize: if the input lacks a URL scheme but looks like a host/path (e.g. "google.co.jp/.." or "www.google.co.jp/.."),
            # try to prepend https:// so urllib.parse can parse netloc/path correctly. This also allows handling inputs
            # like 'google.co.jp/maps/@lat,lon,...' which users may paste without scheme.
            parsed_temp = urllib.parse.urlparse(permalink_url)
            # If the input lacks a URL scheme, only auto-prepend 'https://' when it appears to be an
            # internal qgis-map request (contains 'qgis-map?'). Otherwise keep the raw string and
            # allow Google @-style detection below to run. This avoids accidentally treating arbitrary
            # host/path strings as full URLs and respects the user's instruction.
            if not parsed_temp.scheme:
                if 'qgis-map?' in permalink_url:
                    try:
                        permalink_url_with_scheme = 'https://' + permalink_url
                        parsed_url = urllib.parse.urlparse(permalink_url_with_scheme)
                    except Exception:
                        parsed_url = parsed_temp
                else:
                    parsed_url = parsed_temp
            else:
                parsed_url = parsed_temp

            # If still no recognizable scheme but the string contains a Google/Earth @-format, try parsing it directly
            if not parsed_url.scheme:
                # Prefer Google Earth Web format first
                try:
                    parsed_earth = self._parse_google_earth_url(permalink_url)
                    if parsed_earth:
                        try:
                            # parsed_earth includes estimated scale/zoom when possible
                            self.navigate_to_coordinates(parsed_earth['lon'], parsed_earth['lat'], parsed_earth.get('scale'), parsed_earth.get('zoom'), 'EPSG:4326')
                            try:
                                dbg = f"Parsed Google Earth @ data: {parsed_earth}"
                                print(dbg)
                                self.iface.messageBar().pushMessage("QMap Permalink", dbg, duration=5)
                            except Exception:
                                pass
                            return
                        except Exception:
                            raise
                except Exception:
                    # ignore and fall back to maps parsing
                    pass

                if self._parse_google_maps_at_url(permalink_url):
                    parsed_google = self._parse_google_maps_at_url(permalink_url)
                    if parsed_google:
                        try:
                            self.navigate_to_coordinates(parsed_google['lon'], parsed_google['lat'], parsed_google.get('scale'), parsed_google.get('zoom'), 'EPSG:4326')
                            return
                        except Exception as e:
                            raise

            # HTTP形式のURLを処理（新しいWMS形式と古い形式の両方をサポート）
            # NOTE: 以前は 'http://localhost:' で始まるURLのみ内部ナビゲーションと見なしていましたが
            # ローカルネットワークのIPやホスト名から来る場合も利用されるため、ホスト名に依存せず
            # スキームが http(s) でパスに /wms または /qgis-map を含む場合は内部ナビゲーションとして扱います。
            scheme = (parsed_url.scheme or '').lower()
            scheme = (parsed_url.scheme or '').lower()
            path = parsed_url.path or ''

            # If the URL is an HTTP(S) URL that targets internal endpoints OR contains a Google @lat,lon pattern,
            # handle it internally (do not require opening a browser).
            contains_google_at = False
            try:
                if '@' in path or '@' in parsed_url.query:
                    contains_google_at = True
            except Exception:
                contains_google_at = False

            if scheme in ('http', 'https') and (('/wms' in path or '/qgis-map' in path) or contains_google_at):
                # HTTP URLから直接実行（ブラウザを経由しない）
                # If this is a Google @ style URL, try parsing coordinates first
                if contains_google_at:
                    # Try Google Earth Web format first
                    parsed_earth = None
                    try:
                        parsed_earth = self._parse_google_earth_url(permalink_url)
                    except Exception:
                        parsed_earth = None

                    if parsed_earth:
                        # Use estimated scale/zoom from Earth distance -> zoom inversion
                        try:
                            dbg = f"Parsed Google Earth @ data: {parsed_earth}"
                            print(dbg)
                            try:
                                self.iface.messageBar().pushMessage("QMap Permalink", dbg, duration=5)
                            except Exception:
                                pass
                            self.navigate_to_coordinates(parsed_earth['lon'], parsed_earth['lat'], parsed_earth.get('scale'), parsed_earth.get('zoom'), 'EPSG:4326')
                            return
                        except Exception as e:
                            print(f"navigate_to_coordinates with parsed Earth data failed: {e}")

                    # Fallback to Google Maps @ parser
                    parsed_google = self._parse_google_maps_at_url(permalink_url)
                    # Debug: inform if parser found a map_width_m
                    try:
                        if parsed_google and parsed_google.get('map_width_m') is not None:
                            dbg = f"Detected map_width_m: {parsed_google.get('map_width_m')} (lat={parsed_google.get('lat')}, lon={parsed_google.get('lon')})"
                            print(dbg)
                            try:
                                self.iface.messageBar().pushMessage("QMap Permalink", dbg, duration=5)
                            except Exception:
                                pass
                        else:
                            # also print parsed_google for visibility
                            dbg = f"Parsed Google @ data: {parsed_google}"
                            print(dbg)
                    except Exception:
                        pass
                    if parsed_google:
                        # If map_width_m was provided (e.g. '1763m'), use a single, reliable path:
                        # compute a scale based on center and apply it via navigate_to_coordinates.
                        map_width_m = parsed_google.get('map_width_m')
                        if map_width_m:
                            try:
                                canvas = self.iface.mapCanvas()
                                self.iface.messageBar().pushMessage("QMap Permalink", "試行: 中心ベースでスケールを計算します...", duration=3)
                                computed_scale = self._compute_scale_from_map_width_at_center(parsed_google['lat'], parsed_google['lon'], map_width_m, canvas)
                                print(f"computed_scale from center: {computed_scale}")
                                if computed_scale:
                                    try:
                                        self.navigate_to_coordinates(parsed_google['lon'], parsed_google['lat'], computed_scale, None, 'EPSG:4326')
                                        self.iface.messageBar().pushMessage(
                                            "QMap Permalink",
                                            f"計算したスケールを適用しました（幅約 {map_width_m}m、1:{int(computed_scale)}）。",
                                            duration=3
                                        )
                                        return
                                    except Exception as e:
                                        print(f"navigate_to_coordinates with computed scale failed: {e}")
                                else:
                                    # Could not compute scale: fall back to center-only move and inform user
                                    try:
                                        canvas = self.iface.mapCanvas()
                                        dest_crs = canvas.mapSettings().destinationCrs()
                                        cx, cy = self._convert_wgs84_to_crs(parsed_google['lat'], parsed_google['lon'], dest_crs.authid())
                                        if cx is not None and cy is not None:
                                            canvas.setCenter(QgsPointXY(float(cx), float(cy)))
                                            canvas.refresh()
                                            self.iface.messageBar().pushMessage(
                                                "QMap Permalink",
                                                f"座標 ({parsed_google['lon']:.6f}, {parsed_google['lat']:.6f}) に移動しました（スケールは維持されました）。",
                                                duration=3
                                            )
                                            return
                                    except Exception:
                                        pass
                            except Exception as e:
                                print(f"map_width handling failed: {e}")

                        # Fallback: Use parsed scale/zoom if map_width_m wasn't provided or handling failed
                        self.navigate_to_coordinates(parsed_google['lon'], parsed_google['lat'], parsed_google.get('scale'), parsed_google.get('zoom'), 'EPSG:4326')
                        return

                params = urllib.parse.parse_qs(parsed_url.query)

                # パラメータをナビゲーションデータへ変換して処理（location または coordinates をサポート）
                try:
                    navigation_data = self.server_manager._build_navigation_data_from_params(params)
                except ValueError as e:
                    raise

                if navigation_data.get('type') == 'location':
                    # エンコード済み location JSON を処理
                    self.navigate_from_http(navigation_data['location'])
                elif navigation_data.get('type') == 'coordinates':
                    x = navigation_data.get('x')
                    y = navigation_data.get('y')
                    zoom = navigation_data.get('zoom')
                    scale = navigation_data.get('scale')
                    crs = navigation_data.get('crs')
                    rotation = navigation_data.get('rotation')
                    theme_info = navigation_data.get('theme_info')
                    # 直接移動を実行（scale を優先）
                    self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                else:
                    raise ValueError("HTTP URLのパラメータからナビゲーションデータを生成できませんでした。")
                    
            # 従来のカスタムプロトコル形式も維持
            elif permalink_url.startswith('qgis-permalink://'):
                encoded_data = permalink_url[17:]  # "qgis-permalink://"を除去
                json_data = urllib.parse.unquote(encoded_data)
                permalink_data = json.loads(json_data)
                
                # 座標系とextentを復元
                crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
                extent = QgsRectangle(
                    permalink_data['x_min'],
                    permalink_data['y_min'],
                    permalink_data['x_max'],
                    permalink_data['y_max']
                )
                
                # マップキャンバスに適用
                canvas = self.iface.mapCanvas()
                canvas.setDestinationCrs(crs)
                canvas.setExtent(extent)
                canvas.refresh()
                
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    "パーマリンクから地図ビューに移動しました。", 
                    duration=3
                )
                
            else:
                raise ValueError("サポートされていないパーマリンクURL形式です。")
                
        except Exception as e:
            QMessageBox.warning(
                self.iface.mainWindow(),
                "QMap Permalink エラー",
                f"パーマリンクの処理中にエラーが発生しました：\n{str(e)}"
            )
    
    def navigate_from_http(self, location_data):
        """HTTP経由でのナビゲーション処理
        
        Args:
            location_data: エンコードされた位置データ
        """
        try:
            # URLデコードしてJSONパース
            json_data = urllib.parse.unquote(location_data)
            permalink_data = json.loads(json_data)
            
            # 座標系とextentを復元
            crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
            extent = QgsRectangle(
                permalink_data['x_min'],
                permalink_data['y_min'],
                permalink_data['x_max'],
                permalink_data['y_max']
            )
            
            # マップキャンバスに適用
            canvas = self.iface.mapCanvas()
            canvas.setDestinationCrs(crs)
            canvas.setExtent(extent)
            canvas.refresh()
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                "HTTP経由で地図ビューに移動しました。", 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"HTTP地図移動の処理中にエラーが発生しました: {str(e)}")
    
    def navigate_to_coordinates(self, x, y, scale, zoom, crs_auth_id, rotation=None, theme_info=None):
        """座標指定でのナビゲーション処理
        
        Args:
            x: 経度またはX座標
            y: 緯度またはY座標  
            zoom: ズームレベル
            crs_auth_id: 座標系ID (例: "EPSG:4326")
            rotation: 回転角度（度）
            theme_info: テーマ情報（辞書）
        """
        try:
            # 座標系を設定
            crs = QgsCoordinateReferenceSystem(crs_auth_id)

            # scale があればそれを優先して、QGIS のキャンバス API に scale をそのまま適用する
            # ここでは明示的なスケール変換は行わず、canvas.zoomScale を使ってシンプルに反映する
            scale_val = None
            if scale is not None:
                try:
                    scale_val = float(scale)
                except Exception:
                    scale_val = None

            # scale が無ければ zoom から推定する（より精度の高い推定を使用）
            if scale_val is None and zoom is not None:
                try:
                    zoom_val = float(zoom)
                    scale_val = self._estimate_scale_from_zoom(zoom_val)
                except Exception:
                    scale_val = None

            # 最終フォールバック: 明示的な scale/zoom が与えられない場合は
            # 現在のキャンバスの scale を維持する（存在しない場合のみ 1000 を使用）
            if scale_val is None:
                try:
                    canvas_tmp = self.iface.mapCanvas()
                    current_scale = canvas_tmp.scale()
                    if current_scale and current_scale > 0:
                        scale_val = float(current_scale)
                    else:
                        scale_val = 1000.0
                except Exception:
                    scale_val = 1000.0

            # マップキャンバスに適用
            canvas = self.iface.mapCanvas()

            # 保存: 元の destination CRS を退避
            try:
                original_dest_crs = canvas.mapSettings().destinationCrs()
            except Exception:
                original_dest_crs = None


            # キャンバスの destination CRS を切り替えずに適用する実装
            # 手順:
            # 1) 入力座標 (x,y) は crs (crs_auth_id) にあると仮定。これを現在の canvas の destination CRS に変換する
            # 2) 変換した座標を canvas.setCenter に渡す
            # 3) scale の適用は現在のキャンバスの mapUnitsPerPixel を利用して行う（canvas.zoomScale を使用）
            try:
                dest_crs = canvas.mapSettings().destinationCrs()

                # transform request point -> canvas CRS
                try:
                    if crs.authid() == dest_crs.authid():
                        tx = float(x)
                        ty = float(y)
                    else:
                        transform_req_to_dest = QgsCoordinateTransform(crs, dest_crs, QgsProject.instance())
                        pt_dest = transform_req_to_dest.transform(QgsPointXY(float(x), float(y)))
                        tx = float(pt_dest.x())
                        ty = float(pt_dest.y())
                except Exception:
                    # 変換失敗: フォールバックとして入力をそのまま使う（可能性は低い）
                    tx = float(x)
                    ty = float(y)

                # 中心を設定
                try:
                    canvas.setCenter(QgsPointXY(tx, ty))
                except Exception:
                    # setCenter が使えない場合は extent を直接設定する（scale_val をビューワ単位として使用）
                    try:
                        half_width = float(scale_val) / 2.0
                        half_height = float(scale_val) / 2.0
                        extent = QgsRectangle(
                            tx - half_width,
                            ty - half_height,
                            tx + half_width,
                            ty + half_height
                        )
                        canvas.setExtent(extent)
                    except Exception:
                        pass

                # scale 適用: canvas.zoomScale はキャンバスCRS単位のスケール分母を期待する
                # scale_val はリクエスト由来（メートルベースの場合がある）なので、可能なら map_width->scale を正確に算出する
                try:
                    # 最も簡潔に適用: canvas.zoomScale に scale_val を渡す
                    canvas.zoomScale(float(scale_val))
                except Exception:
                    # フォールバック: mapUnitsPerPixel の比率を使って現在の scale を調整
                    try:
                        current_map_units_per_px = canvas.mapUnitsPerPixel()
                        current_scale = canvas.scale()
                        if current_map_units_per_px and current_scale and float(current_map_units_per_px) > 0:
                            # desired_map_units_per_px を求めるため、まずリクエストされた scale_val が 'scale denominator' であるかを想定
                            # scale_val がすでに分母 (1:scale_val) であれば、canvas.zoomScale に直接渡すのが正しい。
                            # ここでは安全のため、現在の scale を維持する手順を試みる（大きな変更を避ける）
                            canvas.zoomScale(float(scale_val))
                    except Exception:
                        pass

                # rotation があれば適用
                if rotation is not None:
                    try:
                        canvas.setRotation(float(rotation))
                    except Exception:
                        pass

                # 最後にリフレッシュ
                canvas.refresh()


            except Exception:
                # 最後のフォールバック: 直接 extent を設定
                try:
                    half_width = float(scale_val) / 2.0
                    half_height = float(scale_val) / 2.0
                    extent = QgsRectangle(
                        float(x) - half_width,
                        float(y) - half_height,
                        float(x) + half_width,
                        float(y) + half_height
                    )
                    canvas.setExtent(extent)
                except Exception:
                    pass

            # テーマ情報がある場合は適用
            theme_applied = False
            if theme_info:
                try:
                    theme_applied = self._apply_theme_from_permalink(theme_info)
                    if theme_applied:
                        print("テーマが正常に適用されました")
                except Exception as e:
                    print(f"テーマ適用エラー: {e}")
            
            canvas.refresh()
            
            # メッセージを表示
            message = f"座標 ({x:.6f}, {y:.6f}) に移動しました。"
            if theme_applied:
                message += " テーマも復元されました。"
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                message, 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"座標移動の処理中にエラーが発生しました: {str(e)}")

    # パネル用のイベントハンドラ

    def handle_navigation_request(self, navigation_data):
        """HTTPリクエストからのナビゲーション要求を安全に処理（メインスレッドで実行）
        
        Args:
            navigation_data: ナビゲーション情報を含む辞書
        """
        try:
            if navigation_data['type'] == 'location':
                # JSON形式のlocationデータを処理
                location_data = navigation_data['location']
                self.navigate_from_http(location_data)
            elif navigation_data['type'] == 'coordinates':
                # 個別座標パラメータを処理
                x = navigation_data['x']
                y = navigation_data['y']
                zoom = navigation_data.get('zoom')
                scale = navigation_data.get('scale')
                crs = navigation_data['crs']
                rotation = navigation_data.get('rotation')
                theme_info = navigation_data.get('theme_info')
                # scale を優先して渡す（None の場合は zoom を使う）
                self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                
            print(f"ナビゲーション完了: {navigation_data['type']}")
            
        except Exception as e:
            print(f"ナビゲーション処理エラー: {e}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink エラー", 
                f"ナビゲーション処理中にエラーが発生しました: {str(e)}", 
                duration=5
            )
    


    # パネル用のイベントハンドラ
    def on_generate_clicked_panel(self):
        """パネル版：パーマリンク生成ボタンがクリックされた時の処理"""
        try:
            # ドロップダウンの選択からテーマ設定を判定
            include_theme = False
            specific_theme = None
            
            if hasattr(self.panel, 'comboBox_themes'):
                selected_option = self.panel.comboBox_themes.currentText()
                
                if selected_option == "-- No Theme (Position Only) --":
                    include_theme = False
                    specific_theme = None
                elif selected_option:  # 実際のテーマ名が選択された場合
                    include_theme = True
                    specific_theme = selected_option
            
            permalink = self.generate_permalink(include_theme=include_theme, specific_theme=specific_theme)
            self.panel.lineEdit_permalink.setText(permalink)
            
            # ナビゲート用の欄にも同じURLを自動設定
            self.panel.lineEdit_navigate.setText(permalink)
            
            # メッセージにテーマ情報の有無を含める
            if include_theme and specific_theme:
                message = self.tr("Permalink with theme '{theme}' generated successfully.").format(theme=specific_theme)
            else:
                message = self.tr("Permalink (position only) generated successfully.")
            
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                message, 
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to generate permalink: {error}").format(error=str(e))
            )

    def on_navigate_clicked_panel(self):
        """パネル版：ナビゲートボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_navigate.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Please enter a permalink URL.")
            )
            return
        # If the user pasted a raw Google @-style path like '/@lat,lon,1763m/' or
        # '@lat,lon,1763m' (possibly without scheme), prefer to treat it as an
        # internal Google-style navigation and pass directly to the internal
        # parser/navigator. This avoids panel-level heuristics opening a browser
        # or rejecting the input before the plugin can parse map_width (m) etc.
        try:
            if '@' in permalink_url and self._parse_google_maps_at_url(permalink_url):
                # Delegate to the central navigate_to_permalink which contains the
                # canonical handling for Google @-style strings (including map_width -> scale).
                try:
                    self.navigate_to_permalink(permalink_url)
                    return
                except Exception:
                    # Fall through to the normal handling below on error
                    pass
        except Exception:
            # Be defensive: ignore parser errors here and continue with regular flow
            pass
        # Parse URL and decide:
        # - If it's an http(s) URL pointing to localhost and contains
        #   internal endpoints (/wms or /qgis-map), route to internal navigation.
        # - Otherwise, open external http(s) URLs in the default browser.
        try:
            parsed = urllib.parse.urlparse(permalink_url)
            path = parsed.path or ''

            # Prioritize internal qgis-map regardless of scheme: if the input contains '/qgis-map' or 'qgis-map?'
            # treat it as an internal request and hand off to navigate_to_permalink.
            lowered = permalink_url.lower()
            if '/qgis-map' in lowered or 'qgis-map?' in lowered:
                self.navigate_to_permalink(permalink_url)
                return

            # If the URL is a Google Maps URL, try to parse the @lat,lon,... form and navigate internally
            lowered_url = permalink_url.lower()
            # Simplified Google detection: if the input contains a coordinate-style '/@' path,
            # a '/maps/' path segment, or the string 'google.' treat it as a Google Maps URL.
            # This keeps the logic simple and ensures inputs like 'maps/@35.8080979,...' are
            # correctly routed.
            # Simplify Google detection: only treat strings that contain an @lat,lon pattern
            # (e.g. @35.8080979,139.5289801) as Google @-style input.
            if re.search(r'@[-0-9.]+,[-0-9.]+', lowered_url):
                try:
                    self.navigate_to_permalink(permalink_url)
                    return
                except Exception as e:
                    QMessageBox.critical(
                        self.iface.mainWindow(),
                        self.tr("QMap Permalink"),
                        self.tr("Failed to navigate to Google Maps URL: {error}").format(error=str(e))
                    )
                    return

            # (Old HTTP-specific handling removed: navigation now prioritizes '/qgis-map' earlier,
            # and Google @-style URLs are handled above. External HTTP(S) links are not opened by
            # Navigate; use the Open button.)

        except Exception:
            # Parsing failed — do NOT fallback to internal navigation for HTTP(S).
            # If the user provided an http(s) URL we should stop and show an error.
            lowered = permalink_url.lower()
            if lowered.startswith('http://') or lowered.startswith('https://'):
                QMessageBox.critical(
                    self.iface.mainWindow(),
                    self.tr("QMap Permalink"),
                    self.tr("Failed to parse or handle the provided HTTP(S) URL.")
                )
                return
            # Otherwise allow non-http schemes to be handled by the existing fallback

        # Strict mode: if the input was not recognized as qgis-map or Google @-style,
        # show an error and do not attempt fallback navigation.
        QMessageBox.critical(
            self.iface.mainWindow(),
            self.tr("QMap Permalink"),
            self.tr("Navigate supports only internal 'qgis-map' links or Google @-style URLs (e.g. /@lat,lon,220m/).")
        )

    def on_copy_clicked_panel(self):
        """パネル版：コピーボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to copy.")
            )
            return
            
        clipboard = QApplication.clipboard()
        success = False

        for _ in range(3):
            clipboard.setText(permalink_url, mode=QClipboard.Clipboard)
            QApplication.processEvents()
            if clipboard.text(mode=QClipboard.Clipboard) == permalink_url:
                if clipboard.supportsSelection():
                    clipboard.setText(permalink_url, mode=QClipboard.Selection)
                success = True
                break
            QThread.msleep(50)

        if success:
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink copied to clipboard."),
                duration=3
            )
        else:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to copy to clipboard. Please try again or copy manually.")
            )

    def on_open_clicked_panel(self):
        """パネル版：ブラウザで開くボタンがクリックされた時の処理"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to open.")
            )
            return
            
        try:
            QDesktopServices.openUrl(QUrl(permalink_url))
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink opened in browser."),
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to open in browser: {error}").format(error=str(e))
            )

    def on_google_maps_clicked_panel(self):
        """パネル版：Google Mapsボタンがクリックされた時の処理"""
        try:
            # 現在の地図ビューから直接ナビゲーションデータを作成
            canvas = self.iface.mapCanvas()
            extent = canvas.extent()
            crs = canvas.mapSettings().destinationCrs()
            scale = canvas.scale()
            
            # 中心点を計算
            center_x = extent.center().x()
            center_y = extent.center().y()
            
            # WGS84座標に変換
            lat, lon = self._convert_to_wgs84(center_x, center_y, crs.authid())
            
            if lat is None or lon is None:
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", "座標変換に失敗しました。", duration=3
                )
                return
            
            # HTTPレスポンス用と同じ形式のナビゲーションデータを作成
            navigation_data = {
                'type': 'coordinates',
                'x': center_x,
                'y': center_y,
                'lat': lat,
                'lon': lon,
                'scale': scale,
                'crs': crs.authid(),
                'zoom': self._estimate_zoom_from_scale(scale)
            }
            
            # HTTPレスポンスと同じメソッドでGoogle Maps URLを生成
            google_maps_url = self._build_google_maps_url(navigation_data)
            if google_maps_url:
                QDesktopServices.openUrl(QUrl(google_maps_url))
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", "Google Mapsで開きました。", duration=3
                )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "QMap Permalink", f"Google Maps起動エラー: {str(e)}", duration=5
            )

    def on_google_earth_clicked_panel(self):
        """パネル版：Google Earthボタンがクリックされた時の処理"""
        try:
            # 現在の地図ビューから直接ナビゲーションデータを作成
            canvas = self.iface.mapCanvas()
            extent = canvas.extent()
            crs = canvas.mapSettings().destinationCrs()
            scale = canvas.scale()
            
            # 中心点を計算
            center_x = extent.center().x()
            center_y = extent.center().y()
            
            # WGS84座標に変換
            lat, lon = self._convert_to_wgs84(center_x, center_y, crs.authid())
            
            if lat is None or lon is None:
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", "座標変換に失敗しました。", duration=3
                )
                return
            
            # HTTPレスポンス用と同じ形式のナビゲーションデータを作成
            navigation_data = {
                'type': 'coordinates',
                'x': center_x,
                'y': center_y,
                'lat': lat,
                'lon': lon,
                'scale': scale,
                'crs': crs.authid(),
                'zoom': self._estimate_zoom_from_scale(scale)
            }
            
            # HTTPレスポンスと同じメソッドでGoogle Earth URLを生成
            google_earth_url = self._build_google_earth_url(navigation_data)
            if google_earth_url:
                QDesktopServices.openUrl(QUrl(google_earth_url))
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", "Google Earthで開きました。", duration=3
                )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "QMap Permalink", f"Google Earth起動エラー: {str(e)}", duration=5
            )
    
    def on_check_access_clicked(self):
        """外部アクセス診断ボタンがクリックされた時の処理"""
        try:
            # 診断を実行
            result = self.server_manager.check_external_access()
            
            # 結果をダイアログで表示
            from qgis.PyQt.QtWidgets import QMessageBox, QTextEdit, QVBoxLayout, QDialog, QPushButton
            
            dialog = QDialog(self.iface.mainWindow())
            dialog.setWindowTitle("外部アクセス診断")
            dialog.setMinimumWidth(600)
            dialog.setMinimumHeight(400)
            
            layout = QVBoxLayout()
            
            # 診断結果をテキストエリアに表示
            text_edit = QTextEdit()
            text_edit.setReadOnly(True)
            text_edit.setPlainText(result['message'])
            layout.addWidget(text_edit)
            
            # ファイアウォール警告がある場合、ルール追加ボタンを表示
            if result.get('firewall_warning') and result.get('port'):
                firewall_btn = QPushButton(f"ファイアウォールルールを追加 (ポート {result['port']}) - 管理者権限が必要")
                def add_firewall_rule():
                    # 確認メッセージを表示
                    from qgis.PyQt.QtWidgets import QMessageBox
                    
                    # Qt5/Qt6互換性のためStandardButtonを取得
                    try:
                        Yes = QMessageBox.StandardButton.Yes
                        No = QMessageBox.StandardButton.No
                    except AttributeError:
                        Yes = QMessageBox.Yes
                        No = QMessageBox.No
                    
                    reply = QMessageBox.question(
                        dialog,
                        "管理者権限の昇格",
                        f"ポート {result['port']} を許可するファイアウォールルールを追加します。\n\n"
                        "この操作には管理者権限が必要です。\n"
                        "Windowsのユーザーアカウント制御(UAC)ダイアログが表示されます。\n\n"
                        "続行しますか?",
                        Yes | No,
                        No
                    )
                    
                    if reply != Yes:
                        return
                    
                    # ボタンを一時的に無効化
                    firewall_btn.setEnabled(False)
                    firewall_btn.setText("実行中...")
                    QApplication.processEvents()  # UI更新
                    
                    # ファイアウォールルールを追加(管理者権限昇格を試みる)
                    rule_result = self.server_manager.add_firewall_rule(result['port'], request_elevation=True)
                    
                    # ボタンを再度有効化
                    firewall_btn.setEnabled(True)
                    firewall_btn.setText(f"ファイアウォールルールを追加 (ポート {result['port']}) - 管理者権限が必要")
                    
                    if rule_result['success']:
                        QMessageBox.information(
                            dialog,
                            "成功",
                            rule_result['message']
                        )
                        # 再診断して結果を更新
                        new_result = self.server_manager.check_external_access()
                        text_edit.setPlainText(new_result['message'])
                        # ボタンを無効化
                        firewall_btn.setEnabled(False)
                        firewall_btn.setText("ルールを追加済み")
                    elif rule_result.get('admin_required'):
                        # 管理者権限の昇格がキャンセルされた場合
                        from qgis.PyQt.QtWidgets import QTextEdit as AdminTextEdit
                        admin_dialog = QDialog(dialog)
                        admin_dialog.setWindowTitle("手動での実行が必要")
                        admin_dialog.setMinimumWidth(500)
                        admin_dialog.setMinimumHeight(200)
                        
                        admin_layout = QVBoxLayout()
                        
                        admin_text = AdminTextEdit()
                        admin_text.setReadOnly(True)
                        admin_text.setPlainText(rule_result['message'])
                        admin_layout.addWidget(admin_text)
                        
                        # コマンドをコピーするボタン
                        copy_cmd_btn = QPushButton("コマンドをコピー")
                        def copy_command():
                            QApplication.clipboard().setText(rule_result.get('command', ''))
                            self.iface.messageBar().pushMessage(
                                "QMap Permalink", "コマンドをコピーしました", duration=2
                            )
                        copy_cmd_btn.clicked.connect(copy_command)
                        admin_layout.addWidget(copy_cmd_btn)
                        
                        admin_close_btn = QPushButton("閉じる")
                        admin_close_btn.clicked.connect(admin_dialog.accept)
                        admin_layout.addWidget(admin_close_btn)
                        
                        admin_dialog.setLayout(admin_layout)
                        
                        # Qt5/Qt6互換性
                        try:
                            if hasattr(admin_dialog, 'exec'):
                                admin_dialog.exec()
                            else:
                                admin_dialog.exec_()
                        except Exception:
                            admin_dialog.exec_()
                    else:
                        QMessageBox.warning(
                            dialog,
                            "エラー",
                            rule_result['message']
                        )
                
                firewall_btn.clicked.connect(add_firewall_rule)
                layout.addWidget(firewall_btn)
            
            # URLをコピーするボタン(ローカルネットワークURLがある場合)
            if result.get('local_network_url'):
                copy_btn = QPushButton(f"ネットワークURLをコピー ({result['local_network_url']})")
                def copy_url():
                    QApplication.clipboard().setText(result['local_network_url'])
                    self.iface.messageBar().pushMessage(
                        "QMap Permalink", "URLをコピーしました", duration=2
                    )
                copy_btn.clicked.connect(copy_url)
                layout.addWidget(copy_btn)
            
            # 閉じるボタン
            close_btn = QPushButton("閉じる")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            dialog.setLayout(layout)
            
            # Qt5/Qt6互換性: exec_() (Qt5) または exec() (Qt6)
            try:
                if hasattr(dialog, 'exec'):
                    dialog.exec()
                else:
                    dialog.exec_()
            except Exception:
                dialog.exec_()
            
        except Exception as e:
            QMessageBox.warning(
                self.iface.mainWindow(),
                "QMap Permalink",
                f"診断エラー: {str(e)}"
            )
    
    def on_standard_port_clicked(self, port):
        """標準ポートボタンがクリックされた時の処理
        
        Args:
            port: 設定するポート番号 (80 or 443)
        """
        try:
            if not self.panel or not hasattr(self.panel, 'spinBox_port'):
                return
            
            # 管理者権限が必要な警告を表示
            from qgis.PyQt.QtWidgets import QMessageBox
            
            warning_msg = f"ポート {port} は標準ポートです。\n\n"
            if port == 80:
                warning_msg += "このポートでサーバーを起動するには管理者権限が必要です。\n"
            elif port == 443:
                warning_msg += "このポートでサーバーを起動するには管理者権限が必要です。\n"
                warning_msg += "また、HTTPSには証明書が必要です（現在未対応）。\n"
            
            warning_msg += f"\nポート番号を {port} に設定しますか？"
            
            # Qt5/Qt6互換性: StandardButtonの取得
            try:
                # Qt6
                if hasattr(QMessageBox, 'StandardButton'):
                    Yes = QMessageBox.StandardButton.Yes
                    No = QMessageBox.StandardButton.No
                # Qt5
                else:
                    Yes = QMessageBox.Yes
                    No = QMessageBox.No
            except Exception:
                # フォールバック
                Yes = 0x00004000  # QMessageBox.Yes in Qt5
                No = 0x00010000   # QMessageBox.No in Qt5
            
            reply = QMessageBox.question(
                self.iface.mainWindow(),
                "QMap Permalink",
                warning_msg,
                Yes | No,
                No
            )
            
            if reply == Yes:
                # スピンボックスの値を更新
                self.panel.spinBox_port.setValue(port)
                
                self.iface.messageBar().pushMessage(
                    "QMap Permalink",
                    f"ポート番号を {port} に設定しました。管理者権限でQGISを再起動してサーバーを起動してください。",
                    duration=5
                )
        except Exception as e:
            QMessageBox.warning(
                self.iface.mainWindow(),
                "QMap Permalink",
                f"ポート設定エラー: {str(e)}"
            )

    # テーマ関連のメソッド群
    
    def _get_current_theme_info(self):
        """現在のテーマ情報を取得（無効化 - 複雑すぎるため）
        
        Returns:
            None: 常にNoneを返す（機能無効化）
        """
        # 複雑すぎて安定しないため、この機能を無効化
        return None
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return None
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return None
            
            # 現在のレイヤー状態を取得
            layer_states = self._get_current_layer_states()
            
            # アクティブなテーマがあるかチェック
            current_theme = self._detect_current_theme(theme_collection, layer_states)
            
            theme_info = {
                'version': '1.0',
                'current_theme': current_theme,
                'layer_states': layer_states,
                'available_themes': theme_collection.mapThemes()
            }
            
            return theme_info
            
        except ImportError:
            # QGISが利用できない環境
            return None
        except Exception as e:
            print(f"テーマ情報取得エラー: {e}")
            return None
    
    def _get_current_layer_states(self):
        """現在のレイヤー状態を取得
        
        Returns:
            dict: レイヤー状態情報
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeLayer, QgsLayerTreeGroup
            
            project = QgsProject.instance()
            root = project.layerTreeRoot()
            
            layer_states = {}
            
            def collect_layer_info(node, path=""):
                """レイヤーノードから情報を再帰的に収集"""
                if isinstance(node, QgsLayerTreeLayer):
                    layer = node.layer()
                    if layer:
                        layer_id = layer.id()
                        layer_states[layer_id] = {
                            'name': layer.name(),
                            'visible': node.isVisible(),
                            'expanded': node.isExpanded(),
                            'opacity': getattr(layer, 'opacity', lambda: 1.0)(),
                            'path': path,
                            'type': layer.type().name if hasattr(layer.type(), 'name') else str(layer.type())
                        }
                        
                        # スタイル情報も含める（可能であれば）
                        if hasattr(layer, 'styleManager'):
                            try:
                                current_style = layer.styleManager().currentStyle()
                                layer_states[layer_id]['current_style'] = current_style
                                layer_states[layer_id]['available_styles'] = layer.styleManager().styles()
                            except:
                                pass
                                
                elif isinstance(node, QgsLayerTreeGroup):
                    group_path = f"{path}/{node.name()}" if path else node.name()
                    layer_states[f"group:{node.name()}"] = {
                        'name': node.name(),
                        'type': 'group',
                        'visible': node.isVisible(),
                        'expanded': node.isExpanded(),
                        'path': path
                    }
                    
                    # 子要素を再帰的に処理
                    for child in node.children():
                        collect_layer_info(child, group_path)
            
            # ルートから開始
            for child in root.children():
                collect_layer_info(child)
            
            return layer_states
            
        except Exception as e:
            print(f"レイヤー状態取得エラー: {e}")
            return {}
    
    def _detect_current_theme(self, theme_collection, current_layer_states):
        """現在の状態に最も近いテーマを検出
        
        Args:
            theme_collection: QgsMapThemeCollection
            current_layer_states: 現在のレイヤー状態
            
        Returns:
            str or None: テーマ名、または一致するものがない場合はNone
        """
        try:
            available_themes = theme_collection.mapThemes()
            
            for theme_name in available_themes:
                # テーマの状態と現在の状態を比較
                # 実際の詳細比較は複雑になるため、簡単な一致判定を行う
                
                # ここでは簡単な実装として、テーマ名による判定のみ行う
                # 実際の実装では、レイヤーの表示状態やスタイルを詳細に比較する必要がある
                pass
            
            # 簡略化：現在は常にNoneを返す（完全一致の検出は複雑なため）
            return None
            
        except Exception as e:
            print(f"テーマ検出エラー: {e}")
            return None
    
    def _apply_theme_from_permalink(self, theme_name):
        """パーマリンクからテーマを復元・適用
        
        Args:
            theme_name (str): テーマ名
            
        Returns:
            bool: 適用成功かどうか
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeModel
            
            if not theme_name or not isinstance(theme_name, str):
                return False
            
            project = QgsProject.instance()
            if not project:
                return False
            
            # 指定されたテーマを適用
            theme_collection = project.mapThemeCollection()
            if theme_name in theme_collection.mapThemes():
                root = project.layerTreeRoot()
                model = QgsLayerTreeModel(root)
                theme_collection.applyTheme(theme_name, root, model)
                return True
            
            return False
            
        except ImportError:
            # QGISが利用できない環境
            return False
        except Exception as e:
            print(f"テーマ適用エラー: {e}")
            return False
    

    def update_theme_list(self):
        """パネルのテーマ一覧を更新"""
        if not self.panel or not hasattr(self.panel, 'comboBox_themes'):
            return
            
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return
            
            # コンボボックスをクリア
            self.panel.comboBox_themes.clear()
            
            # システムオプションを追加
            self.panel.comboBox_themes.addItem("-- No Theme (Position Only) --")
            
            # 利用可能なテーマを追加
            available_themes = theme_collection.mapThemes()
            for theme_name in sorted(available_themes):
                self.panel.comboBox_themes.addItem(theme_name)
                
            print(f"テーマ一覧を更新: {len(available_themes)} テーマが見つかりました")
            
        except ImportError:
            # QGISが利用できない環境
            print("QGIS環境が利用できません")
        except Exception as e:
            print(f"テーマ一覧更新エラー: {e}")


