# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMapPermalink
                                 A QGIS plugin
 Navigate QGIS map views through external permalink system
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-10-05
        git sha              : $Format:%H$
        copyright            : (C) 2025 by yamamoto-ryuzo
        email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QUrl, QThread, pyqtSignal, QObject
from qgis.PyQt.QtGui import QIcon, QDesktopServices, QClipboard
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QApplication, QDockWidget
from qgis.core import QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPointXY, QgsRectangle
try:
    from qgis.core import qgsfunction
except Exception:
    qgsfunction = None

from qgis.gui import QgsMapCanvas

# ãƒ¦ãƒ¼ã‚¶ãƒ¼é–¢æ•°ã‚’è¿½åŠ ï¼ˆQGIS ç’°å¢ƒã§ã¯ qgsfunction ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ç™»éŒ²ï¼‰
if qgsfunction:
    try:
        @qgsfunction(args='auto', group='Custom', usesgeometry=False)
        def my_custom_function(value1, value2, feature, parent):
            return value1 + value2
    except Exception:
        # ç™»éŒ²å¤±æ•—ã—ã¦ã‚‚é€šå¸¸ã®é–¢æ•°ã¯å®šç¾©ã—ã¦ãŠã
        def my_custom_function(value1, value2, feature, parent):
            return value1 + value2
else:
    # QGIS ç’°å¢ƒã§ãªã„å ´åˆã¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãªã—ã§å®šç¾©
    def my_custom_function(value1, value2, feature, parent):
        return value1 + value2

import os.path
import json
import urllib.parse
import threading
import socket
import math
import html

# ãƒ‘ãƒãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
try:
    from .qmap_permalink_panel import QMapPermalinkPanel
    PANEL_AVAILABLE = True
except ImportError:
    try:
        # ç°¡æ˜“ç‰ˆã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ã—ã¦è©¦è¡Œ
        from .qmap_permalink_panel_simple import SimpleQMapPermalinkPanel as QMapPermalinkPanel
        PANEL_AVAILABLE = True
    except ImportError:
        PANEL_AVAILABLE = False
        QMapPermalinkPanel = None


class NavigationSignals(QObject):
    """QGIS APIã¸ã®å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹ã®ãŸã‚ã®ã‚·ã‚°ãƒŠãƒ«"""
    navigate_requested = pyqtSignal(dict)  # åœ°å›³ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¦æ±‚


class QMapPermalink:
    """QGISã®åœ°å›³ãƒ“ãƒ¥ãƒ¼ã‚’ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ã§ç®¡ç†ãƒ»ãƒŠãƒ“ã‚²ãƒ¼ãƒˆã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³"""

    def __init__(self, iface):
        """ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

        Args:
            iface: QGISã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        
        # ç¿»è¨³ã®åˆæœŸåŒ–
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QMapPermalink_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®å®£è¨€
        self.actions = []
        self.menu = self.tr(u'&QMap Permalink')
        
        # ãƒ‘ãƒãƒ«ï¼ˆãƒ‰ãƒƒã‚¯ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆï¼‰
        self.panel = None

        # HTTPã‚µãƒ¼ãƒãƒ¼é–¢é€£
        self.http_server = None
        self.server_thread = None
        self.server_port = 8089  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ãƒˆ
        self._http_running = False
        self._last_request_text = ""
        
        # ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚·ã‚°ãƒŠãƒ«
        self.navigation_signals = NavigationSignals()
        self.navigation_signals.navigate_requested.connect(self.handle_navigation_request)

        # ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ç¢ºèªï¼ˆåˆå›å®Ÿè¡Œæ™‚ã«ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼‰
        self.first_start = None

    def tr(self, message):
        """ç¿»è¨³ã‚’å–å¾—
        
        Args:
            message: ç¿»è¨³å¯¾è±¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            
        Returns:
            ç¿»è¨³ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        """
        return QCoreApplication.translate('QMapPermalink', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚„ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 

        Args:
            icon_path: ã‚¢ã‚¤ã‚³ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            text: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆ
            callback: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚ŒãŸæ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
            enabled_flag: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã‹ã©ã†ã‹
            add_to_menu: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«è¿½åŠ ã™ã‚‹ã‹ã©ã†ã‹
            add_to_toolbar: ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã«è¿½åŠ ã™ã‚‹ã‹ã©ã†ã‹
            status_tip: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã«è¡¨ç¤ºã™ã‚‹ãƒ’ãƒ³ãƒˆ
            whats_this: What's Thisãƒ˜ãƒ«ãƒ—
            parent: è¦ªã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ

        Returns:
            ä½œæˆã•ã‚ŒãŸQActionã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # ã“ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å°‚ç”¨ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã«è¿½åŠ 
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®GUIè¦ç´ ã‚’ä½œæˆï¼ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿æ™‚ã«å‘¼ã°ã‚Œã‚‹ï¼‰"""
        icon_path = os.path.join(self.plugin_dir, 'icon.png')
        
        # ãƒ‘ãƒãƒ«ç‰ˆã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        if PANEL_AVAILABLE:
            self.add_action(
                icon_path,
                text=self.tr(u'QMap Permalink'),
                callback=self.toggle_panel,
                parent=self.iface.mainWindow())
        else:
            # ãƒ‘ãƒãƒ«ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available. Please try reinstalling the plugin."),
                level=2,  # WARNING
                duration=10
            )

        # HTTPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
        self.start_http_server()

        # åˆå›èµ·å‹•ãƒ•ãƒ©ã‚°
        self.first_start = True

    def toggle_panel(self):
        """ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ"""
        if not PANEL_AVAILABLE:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Panel functionality is not available.")
            )
            return
            
        try:
            if self.panel is None:
                # ãƒ‘ãƒãƒ«åˆ©ç”¨å¯èƒ½æ€§ã‚’ãƒ‡ãƒãƒƒã‚°
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    f"PANEL_AVAILABLE: {PANEL_AVAILABLE}, QMapPermalinkPanel: {QMapPermalinkPanel}", 
                    duration=5
                )
                
                # ãƒ‘ãƒãƒ«ã‚’ä½œæˆ
                self.panel = QMapPermalinkPanel(self.iface.mainWindow())
                
                # ãƒ‘ãƒãƒ«ã®ãƒœã‚¿ãƒ³ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¥ç¶š
                self.panel.pushButton_generate.clicked.connect(self.on_generate_clicked_panel)
                self.panel.pushButton_navigate.clicked.connect(self.on_navigate_clicked_panel)
                self.panel.pushButton_copy.clicked.connect(self.on_copy_clicked_panel)
                if hasattr(self.panel, 'pushButton_open'):
                    self.panel.pushButton_open.clicked.connect(self.on_open_clicked_panel)
                
                # HTTPã‚µãƒ¼ãƒãƒ¼ã®çŠ¶æ…‹ã‚’æ›´æ–°
                server_running = self.http_server is not None
                self.panel.update_server_status(self.server_port, server_running)
                
                # ãƒ†ãƒ¼ãƒä¸€è¦§ã‚’æ›´æ–°
                self.update_theme_list()
                
                # QGISã®ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å·¦å´ã«ãƒ‰ãƒƒã‚­ãƒ³ã‚°
                self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.panel)
                
                # æ—¢å­˜ã®å·¦å´ãƒ‘ãƒãƒ«ãŒã‚ã‚Œã°ã‚¿ãƒ–åŒ–
                self._try_tabify_with_existing_panels()
                
                # ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Panel created successfully."), 
                    duration=3
                )
            else:
                # ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
                if self.panel.isVisible():
                    self.panel.hide()
                else:
                    self.panel.show()
                    
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to create panel: {error}").format(error=str(e))
            )

    def _try_tabify_with_existing_panels(self):
        """æ—¢å­˜ã®å·¦å´ãƒ‘ãƒãƒ«ãŒã‚ã‚Œã°ã‚¿ãƒ–åŒ–ã‚’è©¦è¡Œ"""
        try:
            # QGISãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‹ã‚‰å·¦å´ãƒ‰ãƒƒã‚¯ã‚¨ãƒªã‚¢ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’å–å¾—
            main_window = self.iface.mainWindow()
            
            # ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ‘ãƒãƒ«åã®ãƒªã‚¹ãƒˆï¼ˆå„ªå…ˆé †ä½é †ï¼‰
            preferred_panels = [
                'Layers',           # ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‘ãƒãƒ«
                'Browser',          # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‘ãƒãƒ«
                'Browser2',         # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‘ãƒãƒ«ï¼ˆåˆ¥åï¼‰
                'LayerOrder',       # ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºãƒ‘ãƒãƒ«
                'Processing',       # ãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ãƒ„ãƒ¼ãƒ«ãƒœãƒƒã‚¯ã‚¹
                'History',          # å±¥æ­´ãƒ‘ãƒãƒ«
            ]
            
            target_panel = None
            
            # å„ªå…ˆãƒ‘ãƒãƒ«ã‹ã‚‰æ¤œç´¢
            for panel_name in preferred_panels:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible() and
                        (panel_name.lower() in widget.objectName().lower() or
                         panel_name.lower() in widget.windowTitle().lower())):
                        target_panel = widget
                        break
                if target_panel:
                    break
            
            # å„ªå…ˆãƒ‘ãƒãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å·¦å´ã®æœ€åˆã®ãƒ‘ãƒãƒ«ã‚’ä½¿ç”¨
            if not target_panel:
                for widget in main_window.findChildren(QDockWidget):
                    if (widget != self.panel and 
                        main_window.dockWidgetArea(widget) == Qt.LeftDockWidgetArea and
                        widget.isVisible()):
                        target_panel = widget
                        break
            
            # ã‚¿ãƒ–åŒ–å®Ÿè¡Œ
            if target_panel:
                main_window.tabifyDockWidget(target_panel, self.panel)
                
                # QMapPermalinkãƒ‘ãƒãƒ«ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹
                self.panel.raise_()
                
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Tabified with '{panel_name}' panel.").format(panel_name=target_panel.windowTitle()), 
                    duration=3
                )
            else:
                self.iface.messageBar().pushMessage(
                    self.tr("QMap Permalink"), 
                    self.tr("Displayed as an independent panel on the left side."), 
                    duration=3
                )
                
        except Exception as e:
            # ã‚¿ãƒ–åŒ–ã«å¤±æ•—ã—ã¦ã‚‚ç¶™ç¶š
            print(f"ãƒ‘ãƒãƒ«ã®ã‚¿ãƒ–åŒ–ã§ã‚¨ãƒ©ãƒ¼: {e}")
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                self.tr("Panel displayed on the left side."), 
                duration=3
            )

    def unload(self):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®å‡¦ç†"""
        # HTTPã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢
        self.stop_http_server()
        
        # ãƒ‘ãƒãƒ«ã‚’å‰Šé™¤
        if self.panel is not None:
            self.iface.removeDockWidget(self.panel)
            self.panel = None
        
        # ã‚·ã‚°ãƒŠãƒ«ã‚’åˆ‡æ–­
        if hasattr(self, 'navigation_signals'):
            self.navigation_signals.navigate_requested.disconnect()
        
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QMap Permalink'),
                action)
            self.iface.removeToolBarIcon(action)

    def start_http_server(self):
        """HTTPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•"""
        try:
            if self._http_running:
                return

            # ä½¿ç”¨å¯èƒ½ãªãƒãƒ¼ãƒˆã‚’æ¢ã™
            self.server_port = self.find_available_port(8089, 8099)

            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind(('localhost', self.server_port))
            server_socket.listen(5)
            server_socket.settimeout(1.0)

            self.http_server = server_socket
            self._http_running = True

            self.server_thread = threading.Thread(
                target=self.run_server,
                name="QMapPermalinkHTTP",
                daemon=True,
            )
            self.server_thread.start()

            print(f"QMap Permalink HTTPã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¾ã—ãŸ: http://localhost:{self.server_port}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink",
                f"HTTPã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒˆ: {self.server_port})",
                duration=3
            )

        except Exception as e:
            print(f"HTTPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink ã‚¨ãƒ©ãƒ¼",
                f"HTTPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}",
                duration=5
            )
            self._http_running = False
            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None
    
    def run_server(self):
        """ã‚µãƒ¼ãƒãƒ¼ã‚’å®‰å…¨ã«å®Ÿè¡Œ"""
        try:
            while self._http_running and self.http_server:
                try:
                    conn, addr = self.http_server.accept()
                except socket.timeout:
                    continue
                except OSError:
                    break

                try:
                    self._handle_client_connection(conn, addr)
                except Exception as e:
                    print(f"HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")

        finally:
            self._http_running = False
            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None
            print("HTTPã‚µãƒ¼ãƒãƒ¼ãŒåœæ­¢ã—ã¾ã—ãŸ")
    
    def stop_http_server(self):
        """HTTPã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢"""
        try:
            self._http_running = False

            if self.http_server:
                try:
                    self.http_server.close()
                except Exception:
                    pass
                self.http_server = None

            # ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…ã¤
            if self.server_thread and self.server_thread.is_alive():
                try:
                    self.server_thread.join(timeout=3.0)
                except Exception:
                    pass
                self.server_thread = None

            print("QMap Permalink HTTPã‚µãƒ¼ãƒãƒ¼ãŒåœæ­¢ã—ã¾ã—ãŸ")
            
        except Exception as e:
            print(f"HTTPã‚µãƒ¼ãƒãƒ¼ã®åœæ­¢ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")

    def _handle_client_connection(self, conn, addr):
        """HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è§£æã—ã¦å¿…è¦ã§ã‚ã‚Œã°ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ"""
        with conn:
            request_bytes = self._read_http_request(conn)
            if not request_bytes:
                return

            request_text = request_bytes.decode('iso-8859-1', errors='replace')
            self._last_request_text = request_text

            print("QMap Permalink HTTP request from", addr)
            print(request_text)

            try:
                request_line = request_text.splitlines()[0]
            except IndexError:
                self._send_http_response(conn, 400, "Bad Request", "Invalid HTTP request line.")
                return

            parts = request_line.split()
            if len(parts) < 3:
                self._send_http_response(conn, 400, "Bad Request", "Malformed HTTP request line.")
                return

            method, target, _ = parts

            if method.upper() != 'GET':
                self._send_http_response(conn, 405, "Method Not Allowed", "Only GET is supported.")
                return

            parsed_url = urllib.parse.urlparse(target)

            if parsed_url.path != '/qgis-map':
                self._send_http_response(conn, 404, "Not Found", "Endpoint not found.")
                return

            params = urllib.parse.parse_qs(parsed_url.query)

            try:
                navigation_data = self._build_navigation_data_from_params(params)
            except ValueError as e:
                self._send_http_response(conn, 400, "Bad Request", str(e))
                return

            # ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
            self.navigation_signals.navigate_requested.emit(navigation_data)

            # Google Mapsã¨Google Earthã®URLã‚’ç”Ÿæˆ
            google_maps_url = self._build_google_maps_url(navigation_data)
            google_earth_url = self._build_google_earth_url(navigation_data)
            
            # HTMLãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æ§‹ç¯‰
            body_parts = [
                "<!DOCTYPE html>",
                "<html lang=\"ja\">",
                "<head>",
                "<meta charset=\"utf-8\">",
                "<title>QMap Permalink</title>",
                "<style>",
                "body { font-family: Arial, sans-serif; margin: 20px; }",
                ".link-section { margin: 15px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }",
                ".link-title { font-weight: bold; color: #333; margin-bottom: 5px; }",
                "a { color: #1a73e8; text-decoration: none; word-break: break-all; }",
                "a:hover { text-decoration: underline; }",
                "</style>",
                "</head>",
                "<body>",
                "<h2>QMap Permalink - åœ°å›³ç§»å‹•å®Œäº†</h2>",
                "<p>åœ°å›³ã®ç§»å‹•ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‹ã‚‰åŒã˜åœ°ç‚¹ã‚’ä»–ã®ã‚µãƒ¼ãƒ“ã‚¹ã§ã‚‚è¡¨ç¤ºã§ãã¾ã™ï¼š</p>",
            ]
            
            # Google Mapsãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
            if google_maps_url:
                escaped_maps_url = html.escape(google_maps_url)
                body_parts.extend([
                    "<div class=\"link-section\">",
                    "<div class=\"link-title\">ğŸ—ºï¸ Google Maps ã§è¡¨ç¤º</div>",
                    f"<a href=\"{escaped_maps_url}\" target=\"_blank\" rel=\"noopener noreferrer\">{escaped_maps_url}</a>",
                    "</div>"
                ])
            
            # Google Earthãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
            if google_earth_url:
                escaped_earth_url = html.escape(google_earth_url)
                body_parts.extend([
                    "<div class=\"link-section\">",
                    "<div class=\"link-title\">ğŸŒ Google Earth ã§è¡¨ç¤º</div>",
                    f"<a href=\"{escaped_earth_url}\" target=\"_blank\" rel=\"noopener noreferrer\">{escaped_earth_url}</a>",
                    "</div>"
                ])
            
            # ãƒªãƒ³ã‚¯ãŒãªã„å ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if not google_maps_url and not google_earth_url:
                body_parts.append("<p>å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ç”¨ã®ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</p>")
            
            body_parts.extend([
                "<hr>",
                "<p><small>ã“ã®ãƒšãƒ¼ã‚¸ã¯QGISãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€ŒQMap Permalinkã€ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚</small></p>",
                "</body>",
                "</html>"
            ])
            
            body = "\n".join(body_parts)
            self._send_http_response(conn, 200, "OK", body, "text/html; charset=utf-8")
        
    def _build_navigation_data_from_params(self, params):
        """HTTPã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ

        scale ã‚’å—ã‘å–ã‚Šã€ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã«å«ã‚ã‚‹ã€‚
        zoom ã¯æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ navigation_data ã«å«ã¾ã‚Œã‚‹ã€‚
        """
        if 'location' in params:
            raw_location = params['location'][0]
            navigation_data = {
                'type': 'location',
                'location': raw_location,
            }
            try:
                decoded = urllib.parse.unquote(raw_location)
                data = json.loads(decoded)
                lat = data.get('center_wgs84_lat')
                lon = data.get('center_wgs84_lon')
                if lat is not None and lon is not None:
                    navigation_data['lat'] = float(lat)
                    navigation_data['lon'] = float(lon)
                if 'zoom_level' in data:
                    navigation_data['zoom'] = float(data['zoom_level'])
                navigation_data['crs'] = data.get('crs', 'EPSG:4326')
                navigation_data['center_x'] = data.get('center_x')
                navigation_data['center_y'] = data.get('center_y')
                # scale ã¯æ•°å€¤ã®ã¾ã¾æ¸¡ã™
                navigation_data['scale'] = data.get('scale')
                navigation_data['map_units_per_pixel'] = data.get('map_units_per_pixel')
            except Exception:
                pass
            return navigation_data

        crs = params.get('crs', ['EPSG:4326'])[0]
        zoom_value = self._extract_zoom(params)
        # scale ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚Œã°ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã«å«ã‚ã‚‹
        scale_value = None
        # rotation ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚Œã°å«ã‚ã‚‹
        rotation_value = None
        # theme ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚Œã°å‡¦ç†
        theme_info = None
        if 'scale' in params:
            try:
                scale_value = float(params['scale'][0])
            except Exception:
                raise ValueError("scale ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ•°å€¤ã§æŒ‡å®šã—ã¦ãã ã•ã„")
        if 'rotation' in params:
            try:
                rotation_value = float(params['rotation'][0])
            except Exception:
                raise ValueError("rotation ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ•°å€¤ã§æŒ‡å®šã—ã¦ãã ã•ã„")
        if 'theme' in params:
            try:
                theme_encoded = params['theme'][0]
                theme_name = urllib.parse.unquote(theme_encoded)
                # ã‚·ãƒ³ãƒ—ãƒ«ã«ãƒ†ãƒ¼ãƒåã‚’ä¿å­˜
                theme_info = theme_name
            except Exception as e:
                print(f"ãƒ†ãƒ¼ãƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è§£æã‚¨ãƒ©ãƒ¼: {e}")
                # ã‚¨ãƒ©ãƒ¼ã§ã‚‚å‡¦ç†ã‚’ç¶šè¡Œ

        if 'll' in params:
            lat, lon = self._parse_latlon(params['ll'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if 'q' in params:
            lat, lon = self._parse_latlon(params['q'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if 'center' in params:
            lat, lon = self._parse_latlon(params['center'][0])
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
            }

    # æ–°ä»•æ§˜: ã‚·ãƒ³ãƒ—ãƒ«ãª x/y/scale ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚µãƒãƒ¼ãƒˆï¼ˆæ¨™æº–ã¯ scaleï¼‰
    # ä¾‹ï¼ˆç·¯åº¦çµŒåº¦ï¼‰: /qgis-map?x=139&y=35&scale=1000.0&crs=EPSG:4326 (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ crs=EPSG:4326)
    # ä¾‹ï¼ˆç›´è§’åº§æ¨™ã€ä¾‹ã¨ã—ã¦ EPSG:6677ï¼‰: /qgis-map?x=667700.0&y=4321987.0&scale=1000.0&crs=EPSG:6677
        if 'x' in params and 'y' in params:
            try:
                x_val = float(params['x'][0])
                y_val = float(params['y'][0])
            except Exception:
                raise ValueError("x/y ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ•°å€¤ã§æŒ‡å®šã—ã¦ãã ã•ã„")
            # ç·¯åº¦çµŒåº¦ã¨ã—ã¦æ‰±ã†å ´åˆï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ CRS ãŒ EPSG:4326ï¼‰ã«ã¯ lat/lon ã‚’è¨­å®š
            lat_val = None
            lon_val = None
            if crs.upper().startswith('EPSG:4326'):
                lat_val = float(y_val)
                lon_val = float(x_val)
            return {
                'type': 'coordinates',
                'x': x_val,
                'y': y_val,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat_val,
                'lon': lon_val,
                'scale': scale_value,
                'rotation': rotation_value,
                'theme_info': theme_info,
            }

        if all(key in params for key in ('lat', 'lon')):
            try:
                lat = float(params['lat'][0])
                lon = float(params['lon'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid lat/lon parameters.")
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
                'rotation': rotation_value,
            }

        if all(key in params for key in ('lat', 'lng')):
            try:
                lat = float(params['lat'][0])
                lon = float(params['lng'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid lat/lng parameters.")
            return {
                'type': 'coordinates',
                'x': lon,
                'y': lat,
                'zoom': zoom_value,
                'crs': crs,
                'lat': lat,
                'lon': lon,
                'scale': scale_value,
            }

        if all(key in params for key in ('x', 'y')):
            try:
                x_value = float(params['x'][0])
                y_value = float(params['y'][0])
            except (TypeError, ValueError):
                raise ValueError("Invalid coordinate parameters.")
            data = {
                'type': 'coordinates',
                'x': x_value,
                'y': y_value,
                'zoom': zoom_value,
                'crs': crs,
            }
            if crs.upper() == 'EPSG:4326':
                data['lat'] = y_value
                data['lon'] = x_value
            data['scale'] = scale_value
            data['rotation'] = rotation_value
            return data

        raise ValueError("Missing required parameters.")

    def _read_http_request(self, conn):
        """HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆå…¨ä½“ã‚’èª­ã¿å–ã‚‹"""
        data = b""
        conn.settimeout(2.0)

        while True:
            try:
                chunk = conn.recv(1024)
            except socket.timeout:
                break

            if not chunk:
                break

            data += chunk

            if b"\r\n\r\n" in data:
                break

        return data

    def _send_http_response(self, conn, status_code, reason, body, content_type="text/plain; charset=utf-8"):
        """æœ€å°é™ã®HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’é€ä¿¡"""
        if isinstance(body, str):
            body_bytes = body.encode('utf-8')
        else:
            body_bytes = body

        header_lines = [
            f"HTTP/1.1 {status_code} {reason}",
            f"Content-Length: {len(body_bytes)}",
            f"Content-Type: {content_type}",
            "Connection: close",
            "",
            "",
        ]

        header_bytes = "\r\n".join(header_lines).encode('utf-8')

        try:
            conn.sendall(header_bytes + body_bytes)
        except OSError:
            pass

    def _extract_zoom(self, params):
        """ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—

        æ˜ç¤ºçš„ãªã‚ºãƒ¼ãƒ æŒ‡å®šãŒãªã‘ã‚Œã° None ã‚’è¿”ã™ï¼ˆGoogle ç”¨ã« scale ã‹ã‚‰æ¨å®šã™ã‚‹ï¼‰
        """
        for key in ('z', 'zoom', 'level'):
            if key in params:
                try:
                    return float(params[key][0])
                except (TypeError, ValueError):
                    raise ValueError(f"Invalid {key} parameter.")
        return None

    def _build_google_maps_url(self, navigation_data):
        """ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰Google Mapsç”¨URLã‚’ç”Ÿæˆ

        Google Mapsç”¨ã¯ zoom ãŒå¿…è¦ã€‚zoom ãŒä¸ãˆã‚‰ã‚Œãªã‘ã‚Œã° scale ã‹ã‚‰æ¨å®šã™ã‚‹ã€‚
        æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ zoom=16 ã¨ã™ã‚‹ã€‚
        """
        try:
            if navigation_data.get('type') == 'coordinates':
                lat, lon = self._resolve_coordinates(navigation_data)
                if lat is None or lon is None:
                    return None
                # zoom ãŒç„¡ã‘ã‚Œã° scale ã‹ã‚‰æ¨å®šã—ã€ç„¡ã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ16ã‚’ä½¿ã†
                zoom_value = navigation_data.get('zoom')
                if zoom_value is None:
                    zoom_value = self._estimate_zoom_from_scale(navigation_data.get('scale'))
                if zoom_value is None:
                    zoom_value = 16.0
                # å°æ•°ç‚¹ãƒ¬ãƒ™ãƒ«ã®ã‚ºãƒ¼ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆï¼ˆæœ€å¤§2æ¡ã¾ã§ï¼‰
                zoom_formatted = f"{float(zoom_value):.2f}".rstrip('0').rstrip('.')
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_formatted}z"

            if navigation_data.get('type') == 'location':
                lat = navigation_data.get('lat')
                lon = navigation_data.get('lon')
                zoom_value = navigation_data.get('zoom')

                if lat is None or lon is None:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                    except Exception:
                        data = {}

                    if data:
                        center_lat = data.get('center_wgs84_lat')
                        center_lon = data.get('center_wgs84_lon')
                        if center_lat is not None and center_lon is not None:
                            lat = float(center_lat)
                            lon = float(center_lon)
                        else:
                            center_x = data.get('center_x')
                            center_y = data.get('center_y')
                            crs_authid = data.get('center_crs') or data.get('crs')
                            if center_x is not None and center_y is not None and crs_authid:
                                lat, lon = self._convert_to_wgs84(center_x, center_y, crs_authid)
                        if zoom_value is None:
                            zoom_value = self._estimate_zoom_from_scale(data.get('scale'))

                if (lat is None or lon is None) and navigation_data.get('center_x') is not None:
                    crs_authid = navigation_data.get('crs')
                    lat, lon = self._convert_to_wgs84(
                        navigation_data.get('center_x'),
                        navigation_data.get('center_y'),
                        crs_authid,
                    )

                if lat is None or lon is None:
                    return None

                if zoom_value is None:
                    zoom_value = 16.0

                # å°æ•°ç‚¹ãƒ¬ãƒ™ãƒ«ã®ã‚ºãƒ¼ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆï¼ˆæœ€å¤§2æ¡ã¾ã§ï¼‰
                zoom_formatted = f"{float(zoom_value):.2f}".rstrip('0').rstrip('.')
                return f"https://www.google.co.jp/maps/@{lat:.6f},{lon:.6f},{zoom_formatted}z"

        except Exception:
            return None

        return None

    def _build_google_earth_url(self, navigation_data):
        """ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰Google Earthç”¨URLã‚’ç”Ÿæˆ

        Google Earth Webç‰ˆç”¨ã®URLå½¢å¼: https://earth.google.com/web/@lat,lon,altitude,heading,tilt,roll
        Google Mapsã¨åŒã˜ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›ã‚’ä½¿ç”¨ã—ã¦ã‚ˆã‚Šæ­£ç¢ºãªé«˜åº¦ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
        """
        try:
            if navigation_data.get('type') == 'coordinates':
                lat, lon = self._resolve_coordinates(navigation_data)
                if lat is None or lon is None:
                    return None
                
                # Google Mapsã¨åŒã˜ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«æ¨å®šã‚’ä½¿ç”¨
                zoom_value = navigation_data.get('zoom')
                if zoom_value is None:
                    zoom_value = self._estimate_zoom_from_scale(navigation_data.get('scale'))
                if zoom_value is None:
                    zoom_value = 16.0
                
                # Google Earthç”¨ã®æ­£ç¢ºãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨ˆç®—ï¼ˆå®Ÿæ¸¬å€¤ã«åŸºã¥ãï¼‰
                # å®Ÿæ¸¬åˆ†æ: 1:15695ã‚¹ã‚±ãƒ¼ãƒ« â†’ è·é›¢5554mã€é«˜åº¦22m
                if navigation_data.get('scale'):
                    scale_value = navigation_data['scale']
                else:
                    # ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é€†ç®—
                    estimated_scale = self._estimate_scale_from_zoom(zoom_value)
                    scale_value = estimated_scale
                
                # å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãGoogle Earthç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨ˆç®—
                # å®Ÿæ¸¬å€¤: 1:15695ã‚¹ã‚±ãƒ¼ãƒ« â†’ é«˜åº¦32mã€è·é›¢160699mã€1yè§’åº¦
                if scale_value:
                    # å®Ÿæ¸¬åŸºæº–å€¤
                    reference_scale = 15695.0
                    reference_altitude = 32.03670052  # å®Ÿæ¸¬é«˜åº¦
                    reference_distance = 160699.35527964  # å®Ÿæ¸¬è·é›¢
                    
                    # ã‚¹ã‚±ãƒ¼ãƒ«ã«æ¯”ä¾‹ã—ãŸé«˜åº¦è¨ˆç®—ï¼ˆå®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼‰
                    altitude = reference_altitude * (scale_value / reference_scale) ** 0.5
                    altitude = max(10.0, min(2000.0, altitude))
                    
                    # ã‚¹ã‚±ãƒ¼ãƒ«ã«æ¯”ä¾‹ã—ãŸè·é›¢è¨ˆç®—ï¼ˆå®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼‰
                    distance = reference_distance * (scale_value / reference_scale)
                    distance = max(100.0, min(500000.0, distance))
                else:
                    altitude = 100.0
                    distance = 50000.0
                
                # å®Ÿæ¸¬ã«åŸºã¥ãGoogle Earth URLå½¢å¼ï¼ˆ1yè§’åº¦ã§é©åˆ‡ãªè¡¨ç¤ºï¼‰
                return f"https://earth.google.com/web/@{lat:.6f},{lon:.6f},{altitude:.8f}a,{distance:.8f}d,1y,0h,0t,0r"

            if navigation_data.get('type') == 'location':
                lat = navigation_data.get('lat')
                lon = navigation_data.get('lon')
                zoom_value = navigation_data.get('zoom')

                if lat is None or lon is None:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                    except Exception:
                        data = {}

                    if data:
                        center_lat = data.get('center_wgs84_lat')
                        center_lon = data.get('center_wgs84_lon')
                        if center_lat is not None and center_lon is not None:
                            lat = float(center_lat)
                            lon = float(center_lon)
                        else:
                            center_x = data.get('center_x')
                            center_y = data.get('center_y')
                            crs_authid = data.get('center_crs') or data.get('crs')
                            if center_x is not None and center_y is not None and crs_authid:
                                lat, lon = self._convert_to_wgs84(center_x, center_y, crs_authid)
                        if zoom_value is None:
                            zoom_value = self._estimate_zoom_from_scale(data.get('scale'))

                if (lat is None or lon is None) and navigation_data.get('center_x') is not None:
                    crs_authid = navigation_data.get('crs')
                    lat, lon = self._convert_to_wgs84(
                        navigation_data.get('center_x'),
                        navigation_data.get('center_y'),
                        crs_authid,
                    )

                if lat is None or lon is None:
                    return None

                if zoom_value is None:
                    zoom_value = 16.0

                # Google Earthç”¨ã®æ­£ç¢ºãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨ˆç®—ï¼ˆå®Ÿæ¸¬å€¼ã«åŸºã¥ãï¼‰
                scale_value = navigation_data.get('scale')
                if not scale_value and 'location' in navigation_data:
                    try:
                        decoded = urllib.parse.unquote(navigation_data['location'])
                        data = json.loads(decoded)
                        scale_value = data.get('scale')
                    except Exception:
                        pass
                
                if scale_value:
                    # å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãGoogle Earthç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨ˆç®—
                    # å®Ÿæ¸¬å€¤: 1:15695ã‚¹ã‚±ãƒ¼ãƒ« â†’ é«˜åº¦32mã€è·é›¢160699mã€1yè§’åº¦
                    reference_scale = 15695.0
                    reference_altitude = 32.03670052  # å®Ÿæ¸¬é«˜åº¦
                    reference_distance = 160699.35527964  # å®Ÿæ¸¬è·é›¢
                    
                    # ã‚¹ã‚±ãƒ¼ãƒ«ã«æ¯”ä¾‹ã—ãŸé«˜åº¦è¨ˆç®—ï¼ˆå®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼‰
                    altitude = reference_altitude * (scale_value / reference_scale) ** 0.5
                    altitude = max(10.0, min(2000.0, altitude))
                    
                    # ã‚¹ã‚±ãƒ¼ãƒ«ã«æ¯”ä¾‹ã—ãŸè·é›¢è¨ˆç®—ï¼ˆå®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼‰
                    distance = reference_distance * (scale_value / reference_scale)
                    distance = max(100.0, min(500000.0, distance))
                else:
                    altitude = 100.0
                    distance = 50000.0
                
                # å®Ÿæ¸¬ã«åŸºã¥ãGoogle Earth URLå½¢å¼ï¼ˆ1yè§’åº¦ã§é©åˆ‡ãªè¡¨ç¤ºï¼‰
                return f"https://earth.google.com/web/@{lat:.6f},{lon:.6f},{altitude:.8f}a,{distance:.8f}d,1y,0h,0t,0r"

        except Exception:
            return None

        return None

    def _resolve_coordinates(self, navigation_data):
        """ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰WGS84åº§æ¨™ã‚’æ±‚ã‚ã‚‹"""
        lat = navigation_data.get('lat')
        lon = navigation_data.get('lon')
        if lat is not None and lon is not None:
            return float(lat), float(lon)

        x = navigation_data.get('x')
        y = navigation_data.get('y')
        crs_authid = navigation_data.get('crs')
        if x is None or y is None or crs_authid is None:
            return None, None

        return self._convert_to_wgs84(x, y, crs_authid)


    def _estimate_zoom_from_scale(self, scale):
        """ã‚¹ã‚±ãƒ¼ãƒ«å€¤ã‹ã‚‰Google Mapsç”¨ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’æ¨å®šï¼ˆé€£ç¶šå€¤å¯¾å¿œæ”¹è‰¯ç‰ˆï¼‰
        
        å›ºå®šãƒ†ãƒ¼ãƒ–ãƒ«æ–¹å¼ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€ãƒ†ãƒ¼ãƒ–ãƒ«é–“ã®ä¸­é–“å€¤ã‚’ç·šå½¢è£œé–“ã§è¨ˆç®—ã—ã€
        å°æ•°ç‚¹ãƒ¬ãƒ™ãƒ«ã§ã®è©³ç´°ãªã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«æ¨å®šã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚
        """
        if not scale:
            return 16.0
        try:
            s = float(scale)
            if s <= 0:
                return 16.0

            # QGISå®Ÿã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œã®æ”¹è‰¯ç‰ˆå›ºå®šã‚¹ã‚±ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«
            # è©³ç´°ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆ1:500ã€œ1:25000ï¼‰ã§+1ã€œ2ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ä¸Šã’ã¦èª¿æ•´
            scale_table = {
                0: 400_000_000.0, 1: 200_000_000.0, 2: 100_000_000.0, 3: 60_000_000.0, 4: 30_000_000.0,
                5: 15_000_000.0, 6: 8_000_000.0, 7: 4_000_000.0, 8: 2_000_000.0, 9: 1_000_000.0,
                # ä¸­ã€œè©³ç´°ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é«˜ã‚ºãƒ¼ãƒ æ–¹å‘ã«èª¿æ•´
                10: 600_000.0,    # å…ƒ: 400_000.0 â†’ ã‚ˆã‚Šè©³ç´°ã«
                11: 300_000.0,    # å…ƒ: 200_000.0 â†’ ã‚ˆã‚Šè©³ç´°ã«
                12: 150_000.0,    # å…ƒ: 100_000.0 â†’ ã‚ˆã‚Šè©³ç´°ã«
                13: 75_000.0,     # å…ƒ: 40_000.0 â†’ å¤§å¹…ã«è©³ç´°åŒ–
                14: 40_000.0,     # å…ƒ: 20_000.0 â†’ 2å€è©³ç´°
                15: 20_000.0,     # å…ƒ: 10_000.0 â†’ 2å€è©³ç´°
                16: 10_000.0,     # å…ƒ: 5_000.0 â†’ 2å€è©³ç´°
                17: 5_000.0,      # å…ƒ: 2_500.0 â†’ 2å€è©³ç´°
                18: 2_500.0,      # å…ƒ: 1_250.0 â†’ 2å€è©³ç´°
                19: 1_250.0,      # å…ƒ: 600.0 â†’ å¤§å¹…ã«è©³ç´°åŒ–
                20: 600.0,        # å…ƒ: 300.0 â†’ 2å€è©³ç´°
                21: 300.0,        # å…ƒ: 150.0 â†’ 2å€è©³ç´°
                22: 150.0,        # å…ƒ: 75.0 â†’ 2å€è©³ç´°
                23: 75.0,         # å…ƒ: 40.0 â†’ ã‚„ã‚„è©³ç´°ã«
            }

            # å¤–æŒ¿: 24-30 ã¯ 23 ã®å€¤ã‚’åŠåˆ†ãšã¤å¤–æŒ¿
            for z in range(24, 31):
                scale_table[z] = scale_table[23] / (2 ** (z - 23))

            # å¯¾æ•°ç©ºé–“ã§ã®ç·šå½¢è£œé–“ã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«æ¨å®š
            target_log = math.log(s)
            
            # ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
            zoom_levels = sorted(scale_table.keys())
            
            # ç¯„å›²å¤–ã®å‡¦ç†
            if s >= scale_table[zoom_levels[0]]:
                return float(zoom_levels[0])  # æœ€å°ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«
            if s <= scale_table[zoom_levels[-1]]:
                return float(zoom_levels[-1])  # æœ€å¤§ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«
            
            # ç·šå½¢è£œé–“ã§ä¸­é–“å€¤ã‚’è¨ˆç®—
            for i in range(len(zoom_levels) - 1):
                z1, z2 = zoom_levels[i], zoom_levels[i + 1]
                s1, s2 = scale_table[z1], scale_table[z2]
                
                # å¯¾è±¡ã‚¹ã‚±ãƒ¼ãƒ«ãŒ2ã¤ã®ãƒ†ãƒ¼ãƒ–ãƒ«å€¤ã®é–“ã«ã‚ã‚‹å ´åˆ
                if s1 >= s >= s2:
                    # å¯¾æ•°ç©ºé–“ã§ã®ç·šå½¢è£œé–“
                    log_s1, log_s2 = math.log(s1), math.log(s2)
                    # è£œé–“ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆ0.0ã€œ1.0ï¼‰
                    t = (target_log - log_s1) / (log_s2 - log_s1) if log_s2 != log_s1 else 0.0
                    # ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’ç·šå½¢è£œé–“
                    interpolated_zoom = z1 + t * (z2 - z1)
                    return max(0.0, min(30.0, interpolated_zoom))
            
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆç†è«–çš„ã«ã¯åˆ°é”ã—ãªã„ã¯ãšï¼‰
            return 16.0
            
        except (ValueError, TypeError, OverflowError):
            return 16.0

    def _zoom_to_earth_distance(self, zoom_level):
        """ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‹ã‚‰Google Earthç”¨ã®é©åˆ‡ãªè·é›¢ã‚’è¨ˆç®—
        
        Args:
            zoom_level: ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ï¼ˆå°æ•°ç‚¹å¯ï¼‰
            
        Returns:
            è·é›¢ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
        """
        if zoom_level is None:
            return 5000
            
        try:
            z = float(zoom_level)
            # ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¯¾å¿œã™ã‚‹è·é›¢ãƒ†ãƒ¼ãƒ–ãƒ«
            zoom_distances = {
                0: 20000000, 1: 10000000, 2: 5000000, 3: 2000000, 4: 1000000,
                5: 500000, 6: 200000, 7: 100000, 8: 50000, 9: 20000,
                10: 10000, 11: 5000, 12: 2000, 13: 1000, 14: 500,
                15: 200, 16: 100, 17: 50, 18: 20, 19: 10, 20: 5
            }
            
            # æœ€ã‚‚è¿‘ã„æ•´æ•°ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã®è·é›¢ã‚’ä½¿ç”¨
            rounded_zoom = max(0, min(20, round(z)))
            return zoom_distances.get(rounded_zoom, 5000)
            
        except (ValueError, TypeError):
            return 5000

    def _estimate_scale_from_zoom(self, zoom_level):
        """ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«å€¤ã‚’é€†ç®—ï¼ˆå°æ•°ç‚¹å¯¾å¿œç‰ˆï¼‰
        
        å°æ•°ç‚¹ãƒ¬ãƒ™ãƒ«ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«ã‚‚å¯¾å¿œã—ã€ç·šå½¢è£œé–“ã§ã‚¹ã‚±ãƒ¼ãƒ«å€¤ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
        
        Args:
            zoom_level: ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ï¼ˆå°æ•°ç‚¹å¯ï¼‰
            
        Returns:
            æ¨å®šã‚¹ã‚±ãƒ¼ãƒ«å€¤
        """
        if zoom_level is None:
            return 20000.0  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ãƒ¼ãƒ«
            
        try:
            z = float(zoom_level)
            
            # _estimate_zoom_from_scale ã¨åŒã˜ãƒ†ãƒ¼ãƒ–ãƒ«
            scale_table = {
                0: 400_000_000.0, 1: 200_000_000.0, 2: 100_000_000.0, 3: 60_000_000.0, 4: 30_000_000.0,
                5: 15_000_000.0, 6: 8_000_000.0, 7: 4_000_000.0, 8: 2_000_000.0, 9: 1_000_000.0,
                10: 600_000.0, 11: 300_000.0, 12: 150_000.0, 13: 75_000.0, 14: 40_000.0,
                15: 20_000.0, 16: 10_000.0, 17: 5_000.0, 18: 2_500.0, 19: 1_250.0,
                20: 600.0, 21: 300.0, 22: 150.0, 23: 75.0,
            }
            
            # å¤–æŒ¿å€¤ã‚‚è¨ˆç®—
            for zoom in range(24, 31):
                scale_table[zoom] = scale_table[23] / (2 ** (zoom - 23))
            
            # ç¯„å›²ãƒã‚§ãƒƒã‚¯
            z = max(0.0, min(30.0, z))
            
            # æ•´æ•°ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã®å ´åˆã¯ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰ç›´æ¥å–å¾—
            if z == int(z) and int(z) in scale_table:
                return scale_table[int(z)]
            
            # å°æ•°ç‚¹ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã®å ´åˆã¯ç·šå½¢è£œé–“
            z_floor = int(math.floor(z))
            z_ceil = int(math.ceil(z))
            
            # ç¯„å›²å†…ãƒã‚§ãƒƒã‚¯
            if z_floor < 0:
                z_floor = 0
            if z_ceil > 30:
                z_ceil = 30
            if z_floor not in scale_table:
                z_floor = max([k for k in scale_table.keys() if k <= z_floor], default=0)
            if z_ceil not in scale_table:
                z_ceil = min([k for k in scale_table.keys() if k >= z_ceil], default=30)
                
            # åŒã˜å€¤ã®å ´åˆ
            if z_floor == z_ceil:
                return scale_table.get(z_floor, 20000.0)
            
            # ç·šå½¢è£œé–“ï¼ˆå¯¾æ•°ç©ºé–“ï¼‰
            s1, s2 = scale_table[z_floor], scale_table[z_ceil]
            log_s1, log_s2 = math.log(s1), math.log(s2)
            
            # è£œé–“ä¿‚æ•°
            t = (z - z_floor) / (z_ceil - z_floor) if z_ceil != z_floor else 0.0
            
            # å¯¾æ•°ç©ºé–“ã§è£œé–“ã—ã¦ã‹ã‚‰æŒ‡æ•°ã«æˆ»ã™
            interpolated_log_scale = log_s1 + t * (log_s2 - log_s1)
            interpolated_scale = math.exp(interpolated_log_scale)
            
            return interpolated_scale
            
        except (ValueError, TypeError, OverflowError):
            return 20000.0

    def _convert_to_wgs84(self, x, y, source_crs_authid):
        """ä»»æ„åº§æ¨™ã‚’WGS84ã¸å¤‰æ›"""
        try:
            source_crs = QgsCoordinateReferenceSystem(str(source_crs_authid))
            if not source_crs.isValid():
                return None, None
            target_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            point = transform.transform(QgsPointXY(float(x), float(y)))
            return float(point.y()), float(point.x())
        except Exception:
            return None, None

    def find_available_port(self, start_port, end_port):
        """ä½¿ç”¨å¯èƒ½ãªãƒãƒ¼ãƒˆã‚’æ¢ã™
        
        Args:
            start_port: é–‹å§‹ãƒãƒ¼ãƒˆç•ªå·
            end_port: çµ‚äº†ãƒãƒ¼ãƒˆç•ªå·
            
        Returns:
            ä½¿ç”¨å¯èƒ½ãªãƒãƒ¼ãƒˆç•ªå·
        """
        for port in range(start_port, end_port + 1):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('localhost', port))
                    return port
            except OSError:
                continue
        raise RuntimeError(f"ãƒãƒ¼ãƒˆç¯„å›² {start_port}-{end_port} ã§ä½¿ç”¨å¯èƒ½ãªãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    
    def generate_permalink(self, include_theme=True, specific_theme=None):
        """ç¾åœ¨ã®åœ°å›³ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆ
        
        Args:
            include_theme (bool): ãƒ†ãƒ¼ãƒæƒ…å ±ã‚’å«ã‚ã‚‹ã‹ã©ã†ã‹
            specific_theme (str): æŒ‡å®šã™ã‚‹ãƒ†ãƒ¼ãƒåï¼ˆNone ã®å ´åˆã¯ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä½¿ç”¨ï¼‰
        
        Returns:
            ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯URLæ–‡å­—åˆ—ï¼ˆHTTPå½¢å¼ï¼‰
        """
        # ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚­ãƒ£ãƒ³ãƒã‚¹æƒ…å ±ã‚’å–å¾—
        canvas = self.iface.mapCanvas()
        extent = canvas.extent()
        crs = canvas.mapSettings().destinationCrs()
        scale = canvas.scale()
        # å›è»¢è§’åº¦ï¼ˆåº¦ï¼‰
        rotation = canvas.rotation() if hasattr(canvas, 'rotation') else 0.0
        map_units_per_pixel = canvas.mapUnitsPerPixel()
        center_point = QgsPointXY(
            (extent.xMinimum() + extent.xMaximum()) / 2.0,
            (extent.yMinimum() + extent.yMaximum()) / 2.0,
        )

        # ã‚¹ã‚±ãƒ¼ãƒ«ã‹ã‚‰ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’æ¨å®šï¼ˆWebæ¨™æº–å¯¾å¿œã§ã‚ˆã‚Šæ­£ç¢ºï¼‰
        zoom_level = self._estimate_zoom_from_scale(scale)

        # åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        x_val = f"{center_point.x():.6f}"
        y_val = f"{center_point.y():.6f}"
        crs_id = crs.authid()  # e.g. 'EPSG:3857' or 'EPSG:4326'
        # scale ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ã® scale() ã‚’ä½¿ã†
        scale_val = float(scale) if scale is not None else None
        if scale_val is None:
            # ä¸‡ãŒä¸€ scale ãŒå–å¾—ã§ããªã‘ã‚Œã°ã€ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‹ã‚‰æ¨å®šã—ã¦ scale ã‚’ç®—å‡ºï¼ˆé€†ç®—ã¯ç°¡æ˜“ï¼‰
            # ã“ã“ã§ã¯æ¨å®šå€¤ã¨ã—ã¦ 1000 ã‚’å…¥ã‚Œã¦ãŠã
            scale_val = 1000.0
        
        # åŸºæœ¬URLæ§‹ç¯‰
        permalink_url = (
            f"http://localhost:{self.server_port}/qgis-map?x={x_val}&y={y_val}"
            f"&scale={scale_val:.1f}&crs={crs_id}&rotation={rotation:.2f}"
        )
        
        # ãƒ†ãƒ¼ãƒæƒ…å ±ã‚’è¿½åŠ ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if include_theme and specific_theme:
            # ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ãƒ¼ãƒåã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«è¿½åŠ 
            theme_encoded = urllib.parse.quote(specific_theme)
            permalink_url += f"&theme={theme_encoded}"
        
        return permalink_url

    def navigate_to_permalink(self, permalink_url):
        """ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯URLã‹ã‚‰åœ°å›³ãƒ“ãƒ¥ãƒ¼ã«ç§»å‹•
        
        Args:
            permalink_url: ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯URL
        """
        try:
            # HTTPå½¢å¼ã®URLã‚’å‡¦ç†
            if permalink_url.startswith('http://localhost:') and '/qgis-map' in permalink_url:
                # HTTP URLã‹ã‚‰ç›´æ¥å®Ÿè¡Œï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã‚’çµŒç”±ã—ãªã„ï¼‰
                parsed_url = urllib.parse.urlparse(permalink_url)
                params = urllib.parse.parse_qs(parsed_url.query)

                # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¸å¤‰æ›ã—ã¦å‡¦ç†ï¼ˆlocation ã¾ãŸã¯ coordinates ã‚’ã‚µãƒãƒ¼ãƒˆï¼‰
                try:
                    navigation_data = self._build_navigation_data_from_params(params)
                except ValueError as e:
                    raise

                if navigation_data.get('type') == 'location':
                    # ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ location JSON ã‚’å‡¦ç†
                    self.navigate_from_http(navigation_data['location'])
                elif navigation_data.get('type') == 'coordinates':
                    x = navigation_data.get('x')
                    y = navigation_data.get('y')
                    zoom = navigation_data.get('zoom')
                    scale = navigation_data.get('scale')
                    crs = navigation_data.get('crs')
                    rotation = navigation_data.get('rotation')
                    theme_info = navigation_data.get('theme_info')
                    # ç›´æ¥ç§»å‹•ã‚’å®Ÿè¡Œï¼ˆscale ã‚’å„ªå…ˆï¼‰
                    self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                else:
                    raise ValueError("HTTP URLã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
                    
            # å¾“æ¥ã®ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒˆã‚³ãƒ«å½¢å¼ã‚‚ç¶­æŒ
            elif permalink_url.startswith('qgis-permalink://'):
                encoded_data = permalink_url[17:]  # "qgis-permalink://"ã‚’é™¤å»
                json_data = urllib.parse.unquote(encoded_data)
                permalink_data = json.loads(json_data)
                
                # åº§æ¨™ç³»ã¨extentã‚’å¾©å…ƒ
                crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
                extent = QgsRectangle(
                    permalink_data['x_min'],
                    permalink_data['y_min'],
                    permalink_data['x_max'],
                    permalink_data['y_max']
                )
                
                # ãƒãƒƒãƒ—ã‚­ãƒ£ãƒ³ãƒã‚¹ã«é©ç”¨
                canvas = self.iface.mapCanvas()
                canvas.setDestinationCrs(crs)
                canvas.setExtent(extent)
                canvas.refresh()
                
                self.iface.messageBar().pushMessage(
                    "QMap Permalink", 
                    "ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ã‹ã‚‰åœ°å›³ãƒ“ãƒ¥ãƒ¼ã«ç§»å‹•ã—ã¾ã—ãŸã€‚", 
                    duration=3
                )
                
            else:
                raise ValueError("ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯URLå½¢å¼ã§ã™ã€‚")
                
        except Exception as e:
            QMessageBox.warning(
                self.iface.mainWindow(),
                "QMap Permalink ã‚¨ãƒ©ãƒ¼",
                f"ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼š\n{str(e)}"
            )
    
    def navigate_from_http(self, location_data):
        """HTTPçµŒç”±ã§ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
        
        Args:
            location_data: ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸä½ç½®ãƒ‡ãƒ¼ã‚¿
        """
        try:
            # URLãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦JSONãƒ‘ãƒ¼ã‚¹
            json_data = urllib.parse.unquote(location_data)
            permalink_data = json.loads(json_data)
            
            # åº§æ¨™ç³»ã¨extentã‚’å¾©å…ƒ
            crs = QgsCoordinateReferenceSystem(permalink_data['crs'])
            extent = QgsRectangle(
                permalink_data['x_min'],
                permalink_data['y_min'],
                permalink_data['x_max'],
                permalink_data['y_max']
            )
            
            # ãƒãƒƒãƒ—ã‚­ãƒ£ãƒ³ãƒã‚¹ã«é©ç”¨
            canvas = self.iface.mapCanvas()
            canvas.setDestinationCrs(crs)
            canvas.setExtent(extent)
            canvas.refresh()
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                "HTTPçµŒç”±ã§åœ°å›³ãƒ“ãƒ¥ãƒ¼ã«ç§»å‹•ã—ã¾ã—ãŸã€‚", 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"HTTPåœ°å›³ç§»å‹•ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
    
    def navigate_to_coordinates(self, x, y, scale, zoom, crs_auth_id, rotation=None, theme_info=None):
        """åº§æ¨™æŒ‡å®šã§ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
        
        Args:
            x: çµŒåº¦ã¾ãŸã¯Xåº§æ¨™
            y: ç·¯åº¦ã¾ãŸã¯Yåº§æ¨™  
            zoom: ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«
            crs_auth_id: åº§æ¨™ç³»ID (ä¾‹: "EPSG:4326")
            rotation: å›è»¢è§’åº¦ï¼ˆåº¦ï¼‰
            theme_info: ãƒ†ãƒ¼ãƒæƒ…å ±ï¼ˆè¾æ›¸ï¼‰
        """
        try:
            # åº§æ¨™ç³»ã‚’è¨­å®š
            crs = QgsCoordinateReferenceSystem(crs_auth_id)

            # scale ãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆã—ã¦ã€QGIS ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ API ã« scale ã‚’ãã®ã¾ã¾é©ç”¨ã™ã‚‹
            # ã“ã“ã§ã¯æ˜ç¤ºçš„ãªã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›ã¯è¡Œã‚ãšã€canvas.zoomScale ã‚’ä½¿ã£ã¦ã‚·ãƒ³ãƒ—ãƒ«ã«åæ˜ ã™ã‚‹
            scale_val = None
            if scale is not None:
                try:
                    scale_val = float(scale)
                except Exception:
                    scale_val = None

            # scale ãŒç„¡ã‘ã‚Œã° zoom ã‹ã‚‰ç°¡æ˜“æ¨å®šã™ã‚‹ï¼ˆå¾“æ¥ã®äº’æ›ç”¨ï¼‰
            if scale_val is None and zoom is not None:
                try:
                    zoom_val = float(zoom)
                    scale_val = 1000.0 / (2 ** (zoom_val - 10))
                except Exception:
                    scale_val = None

            # æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if scale_val is None:
                scale_val = 1000.0

            # ãƒãƒƒãƒ—ã‚­ãƒ£ãƒ³ãƒã‚¹ã«é©ç”¨
            canvas = self.iface.mapCanvas()
            canvas.setDestinationCrs(crs)

            try:
                # ä¸­å¿ƒç‚¹ã‚’è¨­å®šã—ã¦ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨ã™ã‚‹ï¼ˆQGIS å´ã§æ­£ã—ã„è¡¨ç¤ºç¯„å›²ãŒè¨ˆç®—ã•ã‚Œã‚‹ï¼‰
                canvas.setCenter(QgsPointXY(float(x), float(y)))
                canvas.zoomScale(float(scale_val))
                # å›è»¢ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°é©ç”¨
                if rotation is not None:
                    try:
                        canvas.setRotation(float(rotation))
                    except Exception:
                        pass
            except Exception:
                # ä¸‡ãŒä¸€ canvas ã® API ãŒä½¿ãˆãªã„/å¤±æ•—ã—ãŸå ´åˆã¯å¾“æ¥ã®ç¯„å›²è¨­å®šã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                half_width = float(scale_val) / 2.0
                half_height = float(scale_val) / 2.0
                extent = QgsRectangle(
                    float(x) - half_width,
                    float(y) - half_height,
                    float(x) + half_width,
                    float(y) + half_height
                )
                canvas.setExtent(extent)

            # ãƒ†ãƒ¼ãƒæƒ…å ±ãŒã‚ã‚‹å ´åˆã¯é©ç”¨
            theme_applied = False
            if theme_info:
                try:
                    theme_applied = self._apply_theme_from_permalink(theme_info)
                    if theme_applied:
                        print("ãƒ†ãƒ¼ãƒãŒæ­£å¸¸ã«é©ç”¨ã•ã‚Œã¾ã—ãŸ")
                except Exception as e:
                    print(f"ãƒ†ãƒ¼ãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")
            
            canvas.refresh()
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            message = f"åº§æ¨™ ({x:.6f}, {y:.6f}) ã«ç§»å‹•ã—ã¾ã—ãŸã€‚"
            if theme_applied:
                message += " ãƒ†ãƒ¼ãƒã‚‚å¾©å…ƒã•ã‚Œã¾ã—ãŸã€‚"
            
            self.iface.messageBar().pushMessage(
                "QMap Permalink", 
                message, 
                duration=3
            )
            
        except Exception as e:
            raise Exception(f"åº§æ¨™ç§»å‹•ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")

    # ãƒ‘ãƒãƒ«ç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©

    def handle_navigation_request(self, navigation_data):
        """HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¦æ±‚ã‚’å®‰å…¨ã«å‡¦ç†ï¼ˆãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œï¼‰
        
        Args:
            navigation_data: ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å«ã‚€è¾æ›¸
        """
        try:
            if navigation_data['type'] == 'location':
                # JSONå½¢å¼ã®locationãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†
                location_data = navigation_data['location']
                self.navigate_from_http(location_data)
            elif navigation_data['type'] == 'coordinates':
                # å€‹åˆ¥åº§æ¨™ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‡¦ç†
                x = navigation_data['x']
                y = navigation_data['y']
                zoom = navigation_data.get('zoom')
                scale = navigation_data.get('scale')
                crs = navigation_data['crs']
                rotation = navigation_data.get('rotation')
                theme_info = navigation_data.get('theme_info')
                # scale ã‚’å„ªå…ˆã—ã¦æ¸¡ã™ï¼ˆNone ã®å ´åˆã¯ zoom ã‚’ä½¿ã†ï¼‰
                self.navigate_to_coordinates(x, y, scale, zoom, crs, rotation, theme_info)
                
            print(f"ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†: {navigation_data['type']}")
            
        except Exception as e:
            print(f"ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            self.iface.messageBar().pushMessage(
                "QMap Permalink ã‚¨ãƒ©ãƒ¼", 
                f"ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", 
                duration=5
            )
    


    # ãƒ‘ãƒãƒ«ç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
    def on_generate_clicked_panel(self):
        """ãƒ‘ãƒãƒ«ç‰ˆï¼šãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ç”Ÿæˆãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç†"""
        try:
            # ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®é¸æŠã‹ã‚‰ãƒ†ãƒ¼ãƒè¨­å®šã‚’åˆ¤å®š
            include_theme = False
            specific_theme = None
            
            if hasattr(self.panel, 'comboBox_themes'):
                selected_option = self.panel.comboBox_themes.currentText()
                
                if selected_option == "-- No Theme (Position Only) --":
                    include_theme = False
                    specific_theme = None
                elif selected_option:  # å®Ÿéš›ã®ãƒ†ãƒ¼ãƒåãŒé¸æŠã•ã‚ŒãŸå ´åˆ
                    include_theme = True
                    specific_theme = selected_option
            
            permalink = self.generate_permalink(include_theme=include_theme, specific_theme=specific_theme)
            self.panel.lineEdit_permalink.setText(permalink)
            
            # ãƒŠãƒ“ã‚²ãƒ¼ãƒˆç”¨ã®æ¬„ã«ã‚‚åŒã˜URLã‚’è‡ªå‹•è¨­å®š
            self.panel.lineEdit_navigate.setText(permalink)
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãƒ†ãƒ¼ãƒæƒ…å ±ã®æœ‰ç„¡ã‚’å«ã‚ã‚‹
            if include_theme and specific_theme:
                message = self.tr("Permalink with theme '{theme}' generated successfully.").format(theme=specific_theme)
            else:
                message = self.tr("Permalink (position only) generated successfully.")
            
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"), 
                message, 
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to generate permalink: {error}").format(error=str(e))
            )

    def on_navigate_clicked_panel(self):
        """ãƒ‘ãƒãƒ«ç‰ˆï¼šãƒŠãƒ“ã‚²ãƒ¼ãƒˆãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç†"""
        permalink_url = self.panel.lineEdit_navigate.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Please enter a permalink URL.")
            )
            return
            
        self.navigate_to_permalink(permalink_url)

    def on_copy_clicked_panel(self):
        """ãƒ‘ãƒãƒ«ç‰ˆï¼šã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç†"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to copy.")
            )
            return
            
        clipboard = QApplication.clipboard()
        success = False

        for _ in range(3):
            clipboard.setText(permalink_url, mode=QClipboard.Clipboard)
            QApplication.processEvents()
            if clipboard.text(mode=QClipboard.Clipboard) == permalink_url:
                if clipboard.supportsSelection():
                    clipboard.setText(permalink_url, mode=QClipboard.Selection)
                success = True
                break
            QThread.msleep(50)

        if success:
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink copied to clipboard."),
                duration=3
            )
        else:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to copy to clipboard. Please try again or copy manually.")
            )

    def on_open_clicked_panel(self):
        """ãƒ‘ãƒãƒ«ç‰ˆï¼šãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ããƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç†"""
        permalink_url = self.panel.lineEdit_permalink.text().strip()
        if not permalink_url:
            QMessageBox.warning(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("No permalink available to open.")
            )
            return
            
        try:
            QDesktopServices.openUrl(QUrl(permalink_url))
            self.iface.messageBar().pushMessage(
                self.tr("QMap Permalink"),
                self.tr("Permalink opened in browser."),
                duration=3
            )
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(),
                self.tr("QMap Permalink"),
                self.tr("Failed to open in browser: {error}").format(error=str(e))
            )

    # ãƒ†ãƒ¼ãƒé–¢é€£ã®ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
    
    def _get_current_theme_info(self):
        """ç¾åœ¨ã®ãƒ†ãƒ¼ãƒæƒ…å ±ã‚’å–å¾—ï¼ˆç„¡åŠ¹åŒ– - è¤‡é›‘ã™ãã‚‹ãŸã‚ï¼‰
        
        Returns:
            None: å¸¸ã«Noneã‚’è¿”ã™ï¼ˆæ©Ÿèƒ½ç„¡åŠ¹åŒ–ï¼‰
        """
        # è¤‡é›‘ã™ãã¦å®‰å®šã—ãªã„ãŸã‚ã€ã“ã®æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–
        return None
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return None
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return None
            
            # ç¾åœ¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‚’å–å¾—
            layer_states = self._get_current_layer_states()
            
            # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ†ãƒ¼ãƒãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            current_theme = self._detect_current_theme(theme_collection, layer_states)
            
            theme_info = {
                'version': '1.0',
                'current_theme': current_theme,
                'layer_states': layer_states,
                'available_themes': theme_collection.mapThemes()
            }
            
            return theme_info
            
        except ImportError:
            # QGISãŒåˆ©ç”¨ã§ããªã„ç’°å¢ƒ
            return None
        except Exception as e:
            print(f"ãƒ†ãƒ¼ãƒæƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _get_current_layer_states(self):
        """ç¾åœ¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‚’å–å¾—
        
        Returns:
            dict: ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹æƒ…å ±
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeLayer, QgsLayerTreeGroup
            
            project = QgsProject.instance()
            root = project.layerTreeRoot()
            
            layer_states = {}
            
            def collect_layer_info(node, path=""):
                """ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒ¼ãƒ‰ã‹ã‚‰æƒ…å ±ã‚’å†å¸°çš„ã«åé›†"""
                if isinstance(node, QgsLayerTreeLayer):
                    layer = node.layer()
                    if layer:
                        layer_id = layer.id()
                        layer_states[layer_id] = {
                            'name': layer.name(),
                            'visible': node.isVisible(),
                            'expanded': node.isExpanded(),
                            'opacity': getattr(layer, 'opacity', lambda: 1.0)(),
                            'path': path,
                            'type': layer.type().name if hasattr(layer.type(), 'name') else str(layer.type())
                        }
                        
                        # ã‚¹ã‚¿ã‚¤ãƒ«æƒ…å ±ã‚‚å«ã‚ã‚‹ï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
                        if hasattr(layer, 'styleManager'):
                            try:
                                current_style = layer.styleManager().currentStyle()
                                layer_states[layer_id]['current_style'] = current_style
                                layer_states[layer_id]['available_styles'] = layer.styleManager().styles()
                            except:
                                pass
                                
                elif isinstance(node, QgsLayerTreeGroup):
                    group_path = f"{path}/{node.name()}" if path else node.name()
                    layer_states[f"group:{node.name()}"] = {
                        'name': node.name(),
                        'type': 'group',
                        'visible': node.isVisible(),
                        'expanded': node.isExpanded(),
                        'path': path
                    }
                    
                    # å­è¦ç´ ã‚’å†å¸°çš„ã«å‡¦ç†
                    for child in node.children():
                        collect_layer_info(child, group_path)
            
            # ãƒ«ãƒ¼ãƒˆã‹ã‚‰é–‹å§‹
            for child in root.children():
                collect_layer_info(child)
            
            return layer_states
            
        except Exception as e:
            print(f"ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {}
    
    def _detect_current_theme(self, theme_collection, current_layer_states):
        """ç¾åœ¨ã®çŠ¶æ…‹ã«æœ€ã‚‚è¿‘ã„ãƒ†ãƒ¼ãƒã‚’æ¤œå‡º
        
        Args:
            theme_collection: QgsMapThemeCollection
            current_layer_states: ç¾åœ¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹
            
        Returns:
            str or None: ãƒ†ãƒ¼ãƒåã€ã¾ãŸã¯ä¸€è‡´ã™ã‚‹ã‚‚ã®ãŒãªã„å ´åˆã¯None
        """
        try:
            available_themes = theme_collection.mapThemes()
            
            for theme_name in available_themes:
                # ãƒ†ãƒ¼ãƒã®çŠ¶æ…‹ã¨ç¾åœ¨ã®çŠ¶æ…‹ã‚’æ¯”è¼ƒ
                # å®Ÿéš›ã®è©³ç´°æ¯”è¼ƒã¯è¤‡é›‘ã«ãªã‚‹ãŸã‚ã€ç°¡å˜ãªä¸€è‡´åˆ¤å®šã‚’è¡Œã†
                
                # ã“ã“ã§ã¯ç°¡å˜ãªå®Ÿè£…ã¨ã—ã¦ã€ãƒ†ãƒ¼ãƒåã«ã‚ˆã‚‹åˆ¤å®šã®ã¿è¡Œã†
                # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹ã‚„ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è©³ç´°ã«æ¯”è¼ƒã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                pass
            
            # ç°¡ç•¥åŒ–ï¼šç¾åœ¨ã¯å¸¸ã«Noneã‚’è¿”ã™ï¼ˆå®Œå…¨ä¸€è‡´ã®æ¤œå‡ºã¯è¤‡é›‘ãªãŸã‚ï¼‰
            return None
            
        except Exception as e:
            print(f"ãƒ†ãƒ¼ãƒæ¤œå‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _apply_theme_from_permalink(self, theme_name):
        """ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯ã‹ã‚‰ãƒ†ãƒ¼ãƒã‚’å¾©å…ƒãƒ»é©ç”¨
        
        Args:
            theme_name (str): ãƒ†ãƒ¼ãƒå
            
        Returns:
            bool: é©ç”¨æˆåŠŸã‹ã©ã†ã‹
        """
        try:
            from qgis.core import QgsProject, QgsLayerTreeModel
            
            if not theme_name or not isinstance(theme_name, str):
                return False
            
            project = QgsProject.instance()
            if not project:
                return False
            
            # æŒ‡å®šã•ã‚ŒãŸãƒ†ãƒ¼ãƒã‚’é©ç”¨
            theme_collection = project.mapThemeCollection()
            if theme_name in theme_collection.mapThemes():
                root = project.layerTreeRoot()
                model = QgsLayerTreeModel(root)
                theme_collection.applyTheme(theme_name, root, model)
                return True
            
            return False
            
        except ImportError:
            # QGISãŒåˆ©ç”¨ã§ããªã„ç’°å¢ƒ
            return False
        except Exception as e:
            print(f"ãƒ†ãƒ¼ãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    

    def update_theme_list(self):
        """ãƒ‘ãƒãƒ«ã®ãƒ†ãƒ¼ãƒä¸€è¦§ã‚’æ›´æ–°"""
        if not self.panel or not hasattr(self.panel, 'comboBox_themes'):
            return
            
        try:
            from qgis.core import QgsProject, QgsMapThemeCollection
            
            project = QgsProject.instance()
            if not project:
                return
                
            theme_collection = project.mapThemeCollection()
            if not theme_collection:
                return
            
            # ã‚³ãƒ³ãƒœãƒœãƒƒã‚¯ã‚¹ã‚’ã‚¯ãƒªã‚¢
            self.panel.comboBox_themes.clear()
            
            # ã‚·ã‚¹ãƒ†ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
            self.panel.comboBox_themes.addItem("-- No Theme (Position Only) --")
            
            # åˆ©ç”¨å¯èƒ½ãªãƒ†ãƒ¼ãƒã‚’è¿½åŠ 
            available_themes = theme_collection.mapThemes()
            for theme_name in sorted(available_themes):
                self.panel.comboBox_themes.addItem(theme_name)
                
            print(f"ãƒ†ãƒ¼ãƒä¸€è¦§ã‚’æ›´æ–°: {len(available_themes)} ãƒ†ãƒ¼ãƒãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")
            
        except ImportError:
            # QGISãŒåˆ©ç”¨ã§ããªã„ç’°å¢ƒ
            print("QGISç’°å¢ƒãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
        except Exception as e:
            print(f"ãƒ†ãƒ¼ãƒä¸€è¦§æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")


